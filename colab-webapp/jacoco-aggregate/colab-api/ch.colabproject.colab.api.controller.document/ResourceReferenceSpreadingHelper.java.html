<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ResourceReferenceSpreadingHelper.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-webapp</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.controller.document</a> &gt; <span class="el_source">ResourceReferenceSpreadingHelper.java</span></div><h1>ResourceReferenceSpreadingHelper.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.controller.document;

import ch.colabproject.colab.api.controller.RequestManager;
import ch.colabproject.colab.api.model.card.AbstractCardType;
import ch.colabproject.colab.api.model.card.Card;
import ch.colabproject.colab.api.model.card.CardContent;
import ch.colabproject.colab.api.model.card.CardTypeRef;
import ch.colabproject.colab.api.model.document.AbstractResource;
import ch.colabproject.colab.api.model.document.Resource;
import ch.colabproject.colab.api.model.document.ResourceRef;
import ch.colabproject.colab.api.model.document.Resourceable;
import ch.colabproject.colab.api.persistence.jpa.card.CardTypeDao;
import ch.colabproject.colab.api.persistence.jpa.document.ResourceDao;
import ch.colabproject.colab.generator.model.exceptions.HttpErrorMessage;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.inject.Inject;

/**
 * Resource and resource reference spread specific logic
 *
 * @author sandra
 */
<span class="nc" id="L32">public class ResourceReferenceSpreadingHelper {</span>

    // *********************************************************************************************
    // injections
    // *********************************************************************************************

    /**
     * Resource persistence handler
     */
    @Inject
    private ResourceDao resourceDao;

    /**
     * Card type persistence handler
     */
    @Inject
    private CardTypeDao cardTypeDao;

    /**
     * TO sudo
     */
    @Inject
    private RequestManager requestManager;

    // *********************************************************************************************
    // when a resource / resource reference is added, spread it down stream with references
    // *********************************************************************************************

    /**
     * Each child of the resource owner acquires a reference to the resource.
     *
     * @param resourceOrRef the resource to reference
     */
    public void spreadAvailableResourceDown(AbstractResource resourceOrRef) {
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (resourceOrRef.getAbstractCardType() != null) {</span>
<span class="nc" id="L67">            requestManager.sudo(() -&gt; {</span>
<span class="nc" id="L68">                AbstractCardType resourceOwner = resourceOrRef.getAbstractCardType();</span>

<span class="nc bnc" id="L70" title="All 2 branches missed.">                for (AbstractCardType cardTypeRef : cardTypeDao</span>
<span class="nc" id="L71">                    .findDirectReferences(resourceOwner)) {</span>
<span class="nc" id="L72">                    makeActiveReference(cardTypeRef, resourceOrRef);</span>
<span class="nc" id="L73">                }</span>

<span class="nc bnc" id="L75" title="All 2 branches missed.">                for (Card implementingCard : resourceOwner.getImplementingCards()) {</span>
<span class="nc" id="L76">                    makeActiveReference(implementingCard, resourceOrRef);</span>
<span class="nc" id="L77">                }</span>
<span class="nc" id="L78">            });</span>
        }

<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (resourceOrRef.getCard() != null) {</span>
<span class="nc" id="L82">            requestManager.sudo(() -&gt; {</span>
<span class="nc" id="L83">                Card resourceOwner = resourceOrRef.getCard();</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">                for (CardContent variant : resourceOwner.getContentVariants()) {</span>
<span class="nc" id="L86">                    makeActiveReference(variant, resourceOrRef);</span>
<span class="nc" id="L87">                }</span>
<span class="nc" id="L88">            });</span>
        }

<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (resourceOrRef.getCardContent() != null) {</span>
<span class="nc" id="L92">            requestManager.sudo(() -&gt; {</span>
<span class="nc" id="L93">                CardContent resourceOwner = resourceOrRef.getCardContent();</span>

<span class="nc bnc" id="L95" title="All 2 branches missed.">                for (Card subCard : resourceOwner.getSubCards()) {</span>
<span class="nc" id="L96">                    makeActiveReference(subCard, resourceOrRef);</span>
<span class="nc" id="L97">                }</span>
<span class="nc" id="L98">            });</span>
        }
<span class="nc" id="L100">    }</span>

    // *********************************************************************************************
    // when a card type reference / card / card content is added,
    // initialize the references from parent's resources / resource references
    // *********************************************************************************************

    /**
     * Create a resource reference for each resource / resource reference of the parent.
     *
     * @param cardTypeRefToFill A card type reference that need references to the up stream
     *                          resources
     *
     * @return the resource references that have been created or revived (or let as it is if nothing
     *         is needed)
     */
    public List&lt;ResourceRef&gt; extractReferencesFromUp(CardTypeRef cardTypeRefToFill) {
<span class="nc" id="L117">        AbstractCardType targetType = cardTypeRefToFill.getTarget();</span>
<span class="nc" id="L118">        List&lt;ResourceRef&gt; refs = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L120" title="All 2 branches missed.">        for (AbstractResource targetResourceOrRef : targetType.getDirectAbstractResources()) {</span>
<span class="nc" id="L121">            ResourceRef ref = makeActiveReference(cardTypeRefToFill, targetResourceOrRef);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (ref != null) {</span>
<span class="nc" id="L123">                refs.add(ref);</span>
            }
<span class="nc" id="L125">        }</span>

<span class="nc" id="L127">        return refs;</span>
    }

    /**
     * Create a resource reference for each resource / resource reference of the parent.
     *
     * @param cardToFill A card that need references to the up stream resources
     */
    public void extractReferencesFromUp(Card cardToFill) {
<span class="nc" id="L136">        CardContent parent = cardToFill.getParent();</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">        for (AbstractResource parentResourceOrRef : parent.getDirectAbstractResources()) {</span>
<span class="nc" id="L139">            makeActiveReference(cardToFill, parentResourceOrRef);</span>
<span class="nc" id="L140">        }</span>

<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (cardToFill.hasCardType()) {</span>
<span class="nc" id="L143">            AbstractCardType type = cardToFill.getCardType();</span>

<span class="nc bnc" id="L145" title="All 2 branches missed.">            for (AbstractResource typeResourceOrRef : type.getDirectAbstractResources()) {</span>
<span class="nc" id="L146">                makeActiveReference(cardToFill, typeResourceOrRef);</span>
<span class="nc" id="L147">            }</span>
        }
<span class="nc" id="L149">    }</span>

    /**
     * Create a resource reference for each resource / resource reference of the parent.
     *
     * @param cardContentToFill A card content that need references to the up stream resources
     */
    public void extractReferencesFromUp(CardContent cardContentToFill) {
<span class="nc" id="L157">        Card parent = cardContentToFill.getCard();</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (AbstractResource parentResourceOrRef : parent.getDirectAbstractResources()) {</span>
<span class="nc" id="L160">            makeActiveReference(cardContentToFill, parentResourceOrRef);</span>
<span class="nc" id="L161">        }</span>
<span class="nc" id="L162">    }</span>

    // *********************************************************************************************
    // do it
    // *********************************************************************************************

    /**
     * If the given target resource (or reference) can have references, ensure that there is an
     * active reference to the given target resource (or reference) for the given owner.
     * &lt;p&gt;
     * For that either be sure the already existing reference for the owner and targeting the same
     * final resource is active or make a new reference.
     *
     * @param owner               the owner of the wanted reference
     * @param targetResourceOrRef the target of the wanted reference
     *
     * @return the resource reference that has been created or revived (or let as it is if nothing
     *         is needed)
     */
    private ResourceRef makeActiveReference(Resourceable owner,
        AbstractResource targetResourceOrRef) {

<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (mustHaveReferences(targetResourceOrRef)) {</span>

<span class="nc" id="L186">            ResourceRef existingMatchingReference = findMatchingResourceRef(owner,</span>
                targetResourceOrRef);

<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (existingMatchingReference != null) {</span>
<span class="nc" id="L190">                ResourceRef aimedResourceRef = reviveAndRetarget(existingMatchingReference,</span>
                    targetResourceOrRef);

<span class="nc" id="L193">                spreadAvailableResourceDown(aimedResourceRef);</span>

<span class="nc" id="L195">                return aimedResourceRef;</span>

            } else {
<span class="nc" id="L198">                ResourceRef aimedResourceRef = initNewReference(owner, targetResourceOrRef);</span>

<span class="nc" id="L200">                spreadAvailableResourceDown(aimedResourceRef);</span>

<span class="nc" id="L202">                return aimedResourceRef;</span>
            }
        }

<span class="nc" id="L206">        return null;</span>
    }

    /**
     * Ascertain if there must be resource references down stream for the given target resource (or
     * reference).
     *
     * @param targetResourceOrRef Resource / resource reference
     *
     * @return true iff the resource can have references
     */
    private boolean mustHaveReferences(AbstractResource targetResourceOrRef) {
<span class="nc" id="L218">        Resource concreteTargetResource = targetResourceOrRef.resolve();</span>

        // do not spread unpublished resource
<span class="nc bnc" id="L221" title="All 4 branches missed.">        if (concreteTargetResource != null &amp;&amp; !concreteTargetResource.isPublished()) {</span>
            // unless between a card and its card contents
<span class="nc bnc" id="L223" title="All 2 branches missed.">            boolean isResourceLinkedToACard = (targetResourceOrRef instanceof Resource)</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                &amp;&amp; targetResourceOrRef.getCard() != null;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (!isResourceLinkedToACard) {</span>
<span class="nc" id="L226">                return false;</span>
            }
        }

        // do not spread references of a type from a card content to its sub cards
<span class="nc bnc" id="L231" title="All 2 branches missed.">        boolean isResourceOrRefLinkedToACardContent = targetResourceOrRef.getCardContent() != null;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (isResourceOrRefLinkedToACardContent) {</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">            boolean isConcreteResourceLinkedToACardType = concreteTargetResource != null</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                &amp;&amp; concreteTargetResource.getAbstractCardType() != null;</span>

<span class="nc bnc" id="L237" title="All 2 branches missed.">            return !isConcreteResourceLinkedToACardType;</span>
        }

        // in all other cases, spread
<span class="nc" id="L241">        return true;</span>
    }

    /**
     * Search for an existing resource reference owned by the given owner and targeting the same
     * final resource as the given target.
     * &lt;p&gt;
     * It ensures that the matching reference is unique.
     *
     * @param owner               the owner of the wanted reference
     * @param targetResourceOrRef the target of the wanted reference
     *
     * @return the matching resource reference
     */
    private ResourceRef findMatchingResourceRef(Resourceable owner,
        AbstractResource targetResourceOrRef) {
<span class="nc" id="L257">        List&lt;ResourceRef&gt; refsOfOwnerWithSameFinalTarget = owner.getDirectAbstractResources()</span>
<span class="nc" id="L258">            .stream()</span>
<span class="nc" id="L259">            .filter(resOrRef -&gt; resOrRef instanceof ResourceRef)</span>
<span class="nc" id="L260">            .map(resOrRef -&gt; (ResourceRef) resOrRef)</span>
<span class="nc" id="L261">            .filter(ref -&gt; Objects.equals(ref.resolve(), targetResourceOrRef.resolve()))</span>
<span class="nc" id="L262">            .collect(Collectors.toList());</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (refsOfOwnerWithSameFinalTarget.size() == 1) {</span>
<span class="nc" id="L265">            return refsOfOwnerWithSameFinalTarget.get(0);</span>
        }

<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (refsOfOwnerWithSameFinalTarget.size() &gt; 1) {</span>
<span class="nc" id="L269">            throw HttpErrorMessage.dataIntegrityFailure();</span>
        }

<span class="nc" id="L272">        return null;</span>
    }

    /**
     * Update the given resource reference so that it is not set as residual, make the same for its
     * descendants. Make the given resource reference target the given target.
     * &lt;p&gt;
     * It can be done only if the resource reference and the new target have the same final concrete
     * resource.
     *
     * @param resourceReference the resource reference to update
     * @param newDirectTarget   the new target of the resource reference
     *
     * @return the resource reference that has been revived (or let as it is if nothing is needed)
     */
    private ResourceRef reviveAndRetarget(ResourceRef resourceReference,
        AbstractResource newDirectTarget) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (!Objects.equals(resourceReference.resolve(), newDirectTarget.resolve())) {</span>
<span class="nc" id="L290">            throw HttpErrorMessage.dataIntegrityFailure();</span>
        }

        // revive
<span class="nc" id="L294">        resourceReference.setResidual(false);</span>

        // retarget
<span class="nc" id="L297">        AbstractResource olderTarget = resourceReference.getTarget();</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (!Objects.equals(olderTarget, newDirectTarget)) {</span>
<span class="nc" id="L300">            resourceReference.setTarget(newDirectTarget);</span>
        }

<span class="nc" id="L303">        return resourceReference;</span>
    }

    /**
     * Make a new resource reference to link to the given owner, targeting the given resource (or
     * reference).
     *
     * @param owner         the entity the new resource reference will be linked to
     * @param resourceOrRef the resource (or reference) target of the new resource reference
     *
     * @return the resource reference that has been created
     */
    private ResourceRef initNewReference(Resourceable owner, AbstractResource targetResourceOrRef) {
<span class="nc" id="L316">        ResourceRef newRef = initNewReferenceFrom(targetResourceOrRef);</span>

<span class="nc" id="L318">        newRef.setOwner(owner);</span>
<span class="nc" id="L319">        owner.getDirectAbstractResources().add(newRef);</span>

<span class="nc" id="L321">        newRef.setTarget(targetResourceOrRef);</span>

<span class="nc" id="L323">        return newRef;</span>

        // no need to persist, it will be done all at once
    }

    /**
     * Initialize a new reference which will have the given resource (or reference) as target.
     *
     * @param targetResourceOrRef The target of the new resource reference
     *
     * @return the new resource reference
     */
    private ResourceRef initNewReferenceFrom(AbstractResource targetResourceOrRef) {
<span class="nc" id="L336">        ResourceRef newRef = new ResourceRef();</span>

<span class="nc" id="L338">        newRef.setCategory(targetResourceOrRef.getCategory());</span>

<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (targetResourceOrRef instanceof ResourceRef) {</span>
<span class="nc" id="L341">            ResourceRef targetResourceRef = (ResourceRef) targetResourceOrRef;</span>

<span class="nc" id="L343">            newRef.setRefused(targetResourceRef.isRefused());</span>
<span class="nc" id="L344">            newRef.setResidual(targetResourceRef.isResidual());</span>
        }

<span class="nc" id="L347">        return newRef;</span>
    }

    // *********************************************************************************************
    // when something is moved, mark the former ancestors resource references as residual
    // when something is un-published, mark the resource references as residual
    // *********************************************************************************************

    /**
     * Each resource reference of the given owner that is linked to a resource of the given former
     * related is marked as residual. As well as all its descendants.
     *
     * @param owner         the owner of the resource references to mark
     * @param formerRelated the not-any-more-related target of the references
     */
    public void spreadDisableResourceDown(Resourceable owner, Resourceable formerRelated) {
<span class="nc" id="L363">        owner.getDirectAbstractResources().stream()</span>
<span class="nc" id="L364">            .filter(resOrRef -&gt; (resOrRef instanceof ResourceRef))</span>
<span class="nc" id="L365">            .map(resOrRef -&gt; ((ResourceRef) resOrRef))</span>
<span class="nc" id="L366">            .filter(ref -&gt; Objects.equals(ref.getTarget().getOwner(), formerRelated))</span>
<span class="nc" id="L367">            .forEach(ref -&gt; markAsResidualRecursively(ref, true));</span>
<span class="nc" id="L368">    }</span>

    /**
     * Disable = mark as residual.
     * &lt;p&gt;
     * Mark the resource's references as residual. Do it as well for all descendants.
     *
     * @param resource the resource
     */
    public void spreadDisableResourceDown(Resource resource) {
<span class="nc" id="L378">        requestManager.sudo(() -&gt; {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">            for (ResourceRef childRef : resourceDao.findDirectReferences(resource)) {</span>
<span class="nc" id="L380">                markAsResidualRecursively(childRef, false);</span>
<span class="nc" id="L381">            }</span>
<span class="nc" id="L382">        });</span>
<span class="nc" id="L383">    }</span>

    /**
     * Disable = mark as residual.
     * &lt;p&gt;
     * Mark the resource's references as residual. Do it as well for all descendants.
     *
     * @param resource   the resource
     * @param alwaysMark if the reference must for sure be marked as residual
     */
    public void spreadDisableResourceDown(Resource resource, boolean alwaysMark) {
<span class="nc" id="L394">        requestManager.sudo(() -&gt; {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            for (ResourceRef childRef : resourceDao.findDirectReferences(resource)) {</span>
<span class="nc" id="L396">                markAsResidualRecursively(childRef, alwaysMark);</span>
<span class="nc" id="L397">            }</span>
<span class="nc" id="L398">        });</span>
<span class="nc" id="L399">    }</span>

    /**
     * Mark the resource reference as residual. Do it as well for all its descendants.
     *
     * @param resourceReference the reference to update
     * @param alwaysMark        if the reference must for sure be marked as residual
     */
    private void markAsResidualRecursively(ResourceRef resourceReference, boolean alwaysMark) {
<span class="nc bnc" id="L408" title="All 4 branches missed.">        if (alwaysMark || resourceReference.getTarget() == null</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            || !mustHaveReferences(resourceReference.getTarget())) {</span>
<span class="nc" id="L410">            resourceReference.setResidual(true);</span>
        }

<span class="nc" id="L413">        requestManager.sudo(() -&gt; {</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            for (ResourceRef childRef : resourceDao.findDirectReferences(resourceReference)) {</span>
<span class="nc" id="L415">                markAsResidualRecursively(childRef, alwaysMark);</span>
<span class="nc" id="L416">            }</span>
<span class="nc" id="L417">        });</span>
<span class="nc" id="L418">    }</span>

    // *********************************************************************************************
    //
    // *********************************************************************************************

    /**
     * Mark the resource reference as refused. Do it as well for all its descendants.
     *
     * @param resourceReference the reference to update
     */
    public void refuseRecursively(ResourceRef resourceReference) {
<span class="nc" id="L430">        resourceReference.setRefused(true);</span>

<span class="nc" id="L432">        requestManager.sudo(() -&gt; {</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            for (ResourceRef childRef : resourceDao.findDirectReferences(resourceReference)) {</span>
<span class="nc" id="L434">                refuseRecursively(childRef);</span>
<span class="nc" id="L435">            }</span>
<span class="nc" id="L436">        });</span>
<span class="nc" id="L437">    }</span>

    /**
     * Mark the resource reference as not refused. Do it as well for all its descendants.
     *
     * @param resourceReference the reference to update
     */
    public void unRefuseRecursively(ResourceRef resourceReference) {
<span class="nc" id="L445">        resourceReference.setRefused(false);</span>

<span class="nc" id="L447">        requestManager.sudo(() -&gt; {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            for (ResourceRef childRef : resourceDao.findDirectReferences(resourceReference)) {</span>
<span class="nc" id="L449">                unRefuseRecursively(childRef);</span>
<span class="nc" id="L450">            }</span>
<span class="nc" id="L451">        });</span>
<span class="nc" id="L452">    }</span>

    /**
     * Mark the resource reference as not residual. Do it as well for all its descendants.
     *
     * @param resourceReference the reference to update
     */
    public void reviveRecursively(ResourceRef resourceReference) {
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (resourceReference.getTarget() != null</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            &amp;&amp; mustHaveReferences(resourceReference.getTarget())) {</span>
<span class="nc" id="L462">            resourceReference.setResidual(false);</span>
        }

<span class="nc" id="L465">        requestManager.sudo(() -&gt; {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            for (ResourceRef childRef : resourceDao.findDirectReferences(resourceReference)) {</span>
<span class="nc" id="L467">                reviveRecursively(childRef);</span>
<span class="nc" id="L468">            }</span>
<span class="nc" id="L469">        });</span>
<span class="nc" id="L470">    }</span>

    // *********************************************************************************************
    //
    // *********************************************************************************************

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>