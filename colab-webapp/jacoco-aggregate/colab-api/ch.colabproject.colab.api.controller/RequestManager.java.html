<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RequestManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-webapp</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.controller</a> &gt; <span class="el_source">RequestManager.java</span></div><h1>RequestManager.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.controller;

import ch.colabproject.colab.api.model.common.Tracking;
import ch.colabproject.colab.api.model.user.Account;
import ch.colabproject.colab.api.model.user.HttpSession;
import ch.colabproject.colab.api.model.user.User;
import ch.colabproject.colab.api.persistence.jpa.user.AccountDao;
import ch.colabproject.colab.api.persistence.jpa.user.HttpSessionDao;
import ch.colabproject.colab.api.security.SessionManager;
import ch.colabproject.colab.api.security.permissions.Conditions.Condition;
import ch.colabproject.colab.generator.model.exceptions.HttpErrorMessage;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.ws.rs.container.ContainerRequestContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Request sidekick.
 *
 * @author maxence
 */
@RequestScoped
<span class="nc" id="L35">public class RequestManager {</span>

    /** logger */
<span class="nc" id="L38">    private static final Logger logger = LoggerFactory.getLogger(RequestManager.class);</span>

    /**
     * Access to the persistence unit
     */
    @PersistenceContext(unitName = &quot;COLAB_PU&quot;)
    private EntityManager em;

    /**
     * Account persistence handling
     */
    @Inject
    private AccountDao accountDao;

    /**
     * Http session persistence handling
     */
    @Inject
    private HttpSessionDao httpSessionDao;

    /**
     * Websocket business logic
     */
    @Inject
    private WebsocketManager websocketManager;

    /**
     * Session manager
     */
    @Inject
    private SessionManager sessionManager;

    /**
     * id HTTP session associated to current request
     */
    private Long httpSessionId;

    /**
     * Timestamp as return by {@link System#currentTimeMillis() } the request starts at
     */
    private long startTime;

    /**
     * Base url request URL
     */
    private String baseUrl;

    /**
     * Id of the current user account
     */
    private Long currentAccountId;

    /**
     * To store condition which have already been evaluated
     */
<span class="nc" id="L93">    private final Map&lt;Condition, Boolean&gt; conditionCache = new HashMap&lt;&gt;();</span>

    /**
     * Indicates if current user can act as an admin. 0 = no sudo greater than 0 =&gt; sudo
     */
<span class="nc" id="L98">    private int sudoAsAdmin = 0;</span>

    /**
     * is the thread run in the so-called security transaction ?
     */
<span class="nc" id="L103">    private boolean inSecurityTx = false;</span>

    /**
     * Is the current transaction already completed ?
     */
<span class="nc" id="L108">    private boolean txDone = false;</span>

    /**
     * In some case, {@link Tracking tracking data} shouldn't be updated. Setting this boolean to
     * prevent allow such behaviour.
     */
<span class="nc" id="L114">    private boolean doNotTrackChange = false;</span>

    /**
     * The HTTP request bound to this request.
     */
    private ContainerRequestContext requestContext;

    /**
     * Get request base url
     *
     * @return url
     */
    public String getBaseUrl() {
<span class="nc" id="L127">        return baseUrl;</span>
    }

    /**
     * Set the request base url
     *
     * @param baseUrl request base url
     */
    public void setBaseUrl(String baseUrl) {
<span class="nc" id="L136">        this.baseUrl = baseUrl;</span>
<span class="nc" id="L137">    }</span>

    /**
     * Get the current httpSession. If subject is not authenticated, null is returned
     *
     * @return the current http session
     */
    public HttpSession getHttpSession() {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (this.httpSessionId != null) {</span>
            // make sure to return a managed httpSession
<span class="nc" id="L147">            return httpSessionDao.findHttpSession(this.httpSessionId);</span>
        } else {
<span class="nc" id="L149">            return null;</span>
        }
    }

    /**
     * Get the current HTTPSession or fails with authenticationRequired exception
     *
     * @return the current http session
     *
     * @throws HttpErrorMessage with authenticationRequired if null
     */
    public HttpSession getAndAssertHttpSession() {
<span class="nc" id="L161">        HttpSession httpSession = getHttpSession();</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">        if (httpSession != null &amp;&amp; httpSession.getAccountId() != null) {</span>
<span class="nc" id="L163">            return httpSession;</span>
        } else {
<span class="nc" id="L165">            throw HttpErrorMessage.authenticationRequired();</span>
        }
    }

    /**
     * Attach id of httpSession to this request
     *
     * @param httpSessionId id of the http session
     */
    public void setHttpSessionId(Long httpSessionId) {
<span class="nc" id="L175">        this.httpSessionId = httpSessionId;</span>
<span class="nc" id="L176">        conditionCache.clear();</span>
<span class="nc" id="L177">    }</span>

    /**
     * Get the current authenticated account
     *
     * @return the current account or null if none
     */
    public Account getCurrentAccount() {
<span class="nc" id="L185">        HttpSession httpSession = getHttpSession();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (httpSession != null) {</span>
<span class="nc" id="L187">            return httpSession.getAccount();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        } else if (this.currentAccountId != null) {</span>
<span class="nc" id="L189">            return accountDao.findAccount(this.currentAccountId);</span>
        } else {
<span class="nc" id="L191">            return null;</span>
        }
    }

    /**
     * Get the current authenticated user
     *
     * @return the current user or null if none
     */
    public User getCurrentUser() {
<span class="nc" id="L201">        Account account = this.getCurrentAccount();</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (account != null) {</span>
<span class="nc" id="L204">            return account.getUser();</span>
        } else {
<span class="nc" id="L206">            return null;</span>
        }
    }

    /**
     * set time the current request started
     *
     * @param timestamp start timestamp
     */
    public void setStartTime(long timestamp) {
<span class="nc" id="L216">        this.startTime = timestamp;</span>
<span class="nc" id="L217">    }</span>

    /**
     * Return the time the request started
     *
     * @return start time timestamp in ms
     */
    public long getStartTime() {
<span class="nc" id="L225">        return startTime;</span>
    }

    /**
     * Is the request ran by an authenticated user ?
     *
     * @return true if the current user is fully authenticated
     */
    public Boolean isAuthenticated() {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        return this.getCurrentAccount() != null;</span>
    }

    /**
     * Set the current account.
     *
     * @param account new current account
     */
    public void login(Account account) {
<span class="nc" id="L243">        this.currentAccountId = account.getId();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (this.requestContext != null) {</span>
            // only create an http session is the request is a HTTP request
<span class="nc" id="L246">            String userAgent = requestContext.getHeaderString(&quot;user-agent&quot;);</span>
<span class="nc" id="L247">            HttpSession httpSession = sessionManager.createHttpSession(account, userAgent);</span>
<span class="nc" id="L248">            setHttpSessionId(httpSession.getId());</span>
        }
<span class="nc" id="L250">    }</span>

    /**
     * Clear current account and unsubscribe from all websocket channels.
     */
    public void logout() {
<span class="nc" id="L256">        HttpSession session = this.getHttpSession();</span>
<span class="nc" id="L257">        this.sudo(() -&gt; {</span>
<span class="nc" id="L258">            this.currentAccountId = null;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (session != null) {</span>
<span class="nc" id="L260">                websocketManager.signoutAndUnsubscribeFromAll(this.getHttpSession().getId());</span>
<span class="nc" id="L261">                sessionManager.deleteHttpSession(session);</span>
            }
<span class="nc" id="L263">            setHttpSessionId(null);</span>
<span class="nc" id="L264">        });</span>
<span class="nc" id="L265">    }</span>

    /**
     * Is current transaction still alive ?
     *
     * @return true if current tx is not dead
     */
    private boolean txExists() {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        return !this.txDone;</span>
    }

    /**
     * Synchronize the persistence context to the underlying database.
     */
    public void flush() {
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (txExists()) {</span>
<span class="nc" id="L281">            em.flush();</span>
        }
<span class="nc" id="L283">    }</span>

    /**
     * Execute some piece of code with admin privileges.
     *
     * @param action code to execute with admin privileges
     */
    public void sudo(Runnable action) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (txExists()) {</span>
            // make sure to flush to check every pending changes before granting admin rights
<span class="nc" id="L293">            em.flush();</span>
        }

<span class="nc" id="L296">        this.sudoAsAdmin++;</span>
<span class="nc" id="L297">        logger.trace(&quot;Sudo #{}&quot;, this.sudoAsAdmin);</span>
<span class="nc" id="L298">        action.run();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (txExists()) {</span>
            // make sure to flush to apply all pending changes with admin rights
<span class="nc" id="L301">            em.flush();</span>
        }

<span class="nc" id="L304">        logger.trace(&quot;EndOfSudo #{}&quot;, this.sudoAsAdmin);</span>

<span class="nc" id="L306">        this.sudoAsAdmin--;</span>
<span class="nc" id="L307">    }</span>

    /**
     * Execute some piece of code with admin privileges and return something.
     *
     * @param &lt;R&gt;    return type
     * @param action code to execute with admin privileges
     *
     * @return action result
     *
     * @throws java.lang.Exception if something is thrown during the call
     */
    public &lt;R&gt; R sudo(Callable&lt;R&gt; action) throws Exception {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (txExists()) {</span>
            // make sure to flush to check every pending changes before granting admin rights
<span class="nc" id="L322">            em.flush();</span>
        }
<span class="nc" id="L324">        this.sudoAsAdmin++;</span>
<span class="nc" id="L325">        logger.trace(&quot;Sudo #{}&quot;, this.sudoAsAdmin);</span>
<span class="nc" id="L326">        R result = action.call();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (txExists()) {</span>
            // make sure to flush to apply all pending changes with admin rights
<span class="nc" id="L329">            em.flush();</span>
        }
<span class="nc" id="L331">        logger.trace(&quot;EndOfSudo #{}&quot;, this.sudoAsAdmin);</span>
<span class="nc" id="L332">        this.sudoAsAdmin--;</span>

<span class="nc" id="L334">        return result;</span>
    }

    /**
     * Is the currentUser is an admin or sudo as an admin ?
     *
     * @return true if current user can act as an admin
     */
    public boolean isAdmin() {
        // the sudoAsAdmin is done at first,
        // so we do not need to get the current user if this condition is fulfilled
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (sudoAsAdmin &gt; 0) {</span>
<span class="nc" id="L346">            return true;</span>
        }

<span class="nc" id="L349">        User currentUser = this.getCurrentUser();</span>
<span class="nc bnc" id="L350" title="All 4 branches missed.">        return currentUser != null &amp;&amp; currentUser.isAdmin();</span>
    }

    /**
     * Register condition result
     *
     * @param condition the condition
     * @param result    the result
     */
    public void registerConditionResult(Condition condition, Boolean result) {
<span class="nc" id="L360">        this.conditionCache.put(condition, result);</span>
<span class="nc" id="L361">    }</span>

    /**
     * Get the cached condition result
     *
     * @param condition condition
     *
     * @return true or false if the condition is cached, null if the condition has not been
     *         evaluated yet
     */
    public Boolean getConditionResult(Condition condition) {
<span class="nc" id="L372">        return this.conditionCache.get(condition);</span>
    }

    /**
     * Is the thread run in a transaction dedicated to security condition evaluation
     *
     * @return true/false
     */
    public boolean isInSecurityTx() {
<span class="nc" id="L381">        return inSecurityTx;</span>
    }

    /**
     * Change the inSecurityTx flag
     *
     * @param inSecurityTx new flag
     */
    public void setInSecurityTx(boolean inSecurityTx) {
<span class="nc" id="L390">        this.inSecurityTx = inSecurityTx;</span>
<span class="nc" id="L391">    }</span>

    /**
     * Check if the current transaction is already done
     *
     * @return whether or not the current transaction is already done
     */
    public boolean isTxDone() {
<span class="nc" id="L399">        return txDone;</span>
    }

    /**
     * Mark the current transaction as done or undone
     *
     * @param txDone whether or not the current transaction is already done
     */
    public void setTxDone(boolean txDone) {
<span class="nc" id="L408">        this.txDone = txDone;</span>
<span class="nc" id="L409">    }</span>

    /**
     * Set Do-Not-Track-Change boolean
     *
     * @param value the new value
     */
    public void setDoNotTrackChange(boolean value) {
<span class="nc" id="L417">        this.doNotTrackChange = value;</span>
<span class="nc" id="L418">    }</span>

    /**
     * Get Do-Not-Track-Change value
     *
     * @return should or shouldn't track entity updates?
     */
    public boolean isDoNotTrackChange() {
<span class="nc" id="L426">        return doNotTrackChange;</span>
    }

    /**
     * Set request context
     *
     * @param requestContext the request context
     */
    public void setRequestContext(ContainerRequestContext requestContext) {
<span class="nc" id="L435">        this.requestContext = requestContext;</span>
<span class="nc" id="L436">    }</span>

    /**
     * get the requestContext
     *
     * @return the request context if request has been intitated by a REST call, null otherwise
     */
    public ContainerRequestContext getRequestContext() {
<span class="nc" id="L444">        return this.requestContext;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>