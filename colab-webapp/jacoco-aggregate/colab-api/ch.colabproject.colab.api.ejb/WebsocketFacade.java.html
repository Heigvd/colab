<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WebsocketFacade.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-webapp</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.ejb</a> &gt; <span class="el_source">WebsocketFacade.java</span></div><h1>WebsocketFacade.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.ejb;

import ch.colabproject.colab.api.model.project.Project;
import ch.colabproject.colab.api.model.user.User;
import ch.colabproject.colab.api.persistence.project.ProjectDao;
import ch.colabproject.colab.api.persistence.user.UserDao;
import ch.colabproject.colab.api.ws.WebsocketEndpoint;
import ch.colabproject.colab.api.ws.channel.ProjectContentChannel;
import ch.colabproject.colab.api.ws.channel.WebsocketEffectiveChannel;
import ch.colabproject.colab.api.ws.message.PrecomputedWsMessages;
import ch.colabproject.colab.api.ws.message.WsSessionIdentifier;
import ch.colabproject.colab.generator.model.exceptions.HttpErrorMessage;
import fish.payara.micro.cdi.Inbound;
import fish.payara.micro.cdi.Outbound;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.enterprise.event.Event;
import javax.enterprise.event.Observes;
import javax.inject.Inject;
import javax.websocket.Session;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Some methods to handle websocket connections. In the future, we may consider using external
 * services (eg Pusher) to delegate such thing. We may want to challenge this implementation in a
 * real &quot;production-like&quot; env.
 *
 * @author maxence
 */
@Singleton // use ejb @Singleton, as it provide concurrrency control
@Startup // make sure the singleton is available as soon as possible
<span class="nc" id="L46">public class WebsocketFacade {</span>

    /** logger */
<span class="nc" id="L49">    private static final Logger logger = LoggerFactory.getLogger(WebsocketFacade.class);</span>

    /**
     * Subscription event name.
     */
    private static final String WS_SUBSCRIPTION_EVENT_CHANNEL = &quot;WS_SUBSCRIPTION_CHANNEL&quot;;

    /**
     * Instance which receive the REST subscription request may not be the same as the one which
     * owns the websocket connection. Use cluster event to delegate the processing to the correct
     * instance.
     */
    @Inject
    @Outbound(eventName = WS_SUBSCRIPTION_EVENT_CHANNEL, loopBack = true)
    private Event&lt;SubscriptionRequest&gt; subscriptionEvents;

    /**
     * Cluster-wide propagation event channel
     */
    private static final String WS_PROPAGATION_CHANNEL = &quot;WS_PROPAGATION_CHANNEL&quot;;

    /**
     * In order to propagate changes to everyone. Each cluster instance must propagate changes to
     * sessions the instance is in change. This is the hz event to request such a propagation.
     */
    @Inject
    @Outbound(eventName = WS_PROPAGATION_CHANNEL, loopBack = true)
    private Event&lt;PrecomputedWsMessages&gt; messagePropagation;

    /**
     * Access control
     */
    @Inject
    private SecurityFacade securityFacade;

    /**
     * Request sidekick
     */
    @Inject
    private RequestManager requestManager;

    /**
     * Project DAO
     */
    @Inject
    private ProjectDao projectDao;

    /**
     * User DAO
     */
    @Inject
    private UserDao userDao;

    /**
     * channel subscriptions.
     */
<span class="nc" id="L105">    private Map&lt;WebsocketEffectiveChannel, Set&lt;Session&gt;&gt; subscriptions = new HashMap&lt;&gt;();</span>

    /**
     * HTTP sessions to websocket sessions registry.
     * &lt;p /&gt;
     * Since one can open several tabs in its browser, all tabs sharing the same httpSessionId
     * (cookie) but each has its own websocket session, we have to maintain such a map.
     * &lt;p /&gt;
     * This is required cancel all subscription on logout.
     */
<span class="nc" id="L115">    private Map&lt;String, Set&lt;Session&gt;&gt; httpSessionToWsSessions = new HashMap&lt;&gt;();</span>

    /**
     * Each websocket session is linked to one http session.
     * &lt;p&gt;
     * This is the {@link httpSessionToWsSessions} reverse registry.
     */
<span class="nc" id="L122">    private Map&lt;Session, String&gt; wsSessionToHttpSession = new HashMap&lt;&gt;();</span>

    /**
     * List the channels each websocket session subscribe to.
     */
<span class="nc" id="L127">    private Map&lt;Session, Set&lt;WebsocketEffectiveChannel&gt;&gt; wsSessionMap = new HashMap&lt;&gt;();</span>

    /**
     * Current user want to subscribe to its own channel.
     *
     * @param sessionId websocket session identifier
     */
    public void subscribeToUserChannel(WsSessionIdentifier sessionId) {
<span class="nc" id="L135">        logger.debug(&quot;Session {} want to subscribe to its UserChannel&quot;, sessionId);</span>
<span class="nc" id="L136">        User user = securityFacade.assertAndGetCurrentUser();</span>
<span class="nc" id="L137">        SubscriptionRequest request = SubscriptionRequest.build(</span>
            SubscriptionRequest.SubscriptionType.SUBSCRIBE,
            SubscriptionRequest.ChannelType.USER,
<span class="nc" id="L140">            user.getId(),</span>
<span class="nc" id="L141">            sessionId.getSessionId(),</span>
<span class="nc" id="L142">            requestManager.getHttpSession().getSessionId());</span>
<span class="nc" id="L143">        subscriptionEvents.fire(request);</span>
<span class="nc" id="L144">    }</span>

    /**
     * Current user want to unsubscribe from its own channel.
     *
     * @param sessionId websocket session identifier
     */
    public void unsubscribeFromUserChannel(WsSessionIdentifier sessionId) {
<span class="nc" id="L152">        logger.debug(&quot;Session {} want to unsubscribe from its UserChannel&quot;, sessionId);</span>
<span class="nc" id="L153">        User user = securityFacade.assertAndGetCurrentUser();</span>
<span class="nc" id="L154">        SubscriptionRequest request = SubscriptionRequest.build(</span>
            SubscriptionRequest.SubscriptionType.UNSUBSCRIBE,
            SubscriptionRequest.ChannelType.USER,
<span class="nc" id="L157">            user.getId(),</span>
<span class="nc" id="L158">            sessionId.getSessionId(),</span>
<span class="nc" id="L159">            requestManager.getHttpSession().getSessionId());</span>
<span class="nc" id="L160">        subscriptionEvents.fire(request);</span>
<span class="nc" id="L161">    }</span>

    /**
     * Current user want to subscribe to a project channel.
     *
     * @param sessionId websocket session identifier
     * @param projectId if of the project
     *
     * @throws HttpErrorMessage notFound if the project does not exists
     */
    public void subscribeToProjectChannel(WsSessionIdentifier sessionId, Long projectId) {
<span class="nc" id="L172">        logger.debug(&quot;Session {} want to subscribe to Project#{}&quot;, sessionId, projectId);</span>
<span class="nc" id="L173">        Project project = projectDao.getProject(projectId);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (project != null) {</span>
<span class="nc" id="L175">            securityFacade.assertIsMember(project);</span>
<span class="nc" id="L176">            SubscriptionRequest request = SubscriptionRequest.build(</span>
                SubscriptionRequest.SubscriptionType.SUBSCRIBE,
                SubscriptionRequest.ChannelType.PROJECT,
<span class="nc" id="L179">                project.getId(),</span>
<span class="nc" id="L180">                sessionId.getSessionId(),</span>
<span class="nc" id="L181">                requestManager.getHttpSession().getSessionId());</span>
<span class="nc" id="L182">            subscriptionEvents.fire(request);</span>
<span class="nc" id="L183">        } else {</span>
<span class="nc" id="L184">            throw HttpErrorMessage.notFound();</span>
        }
<span class="nc" id="L186">    }</span>

    /**
     * Current user want to unsubscribe from a project channel.
     *
     * @param sessionId websocket session identifier
     * @param projectId if of the project
     *
     * @throws HttpErrorMessage notFound if the project does not exists
     */
    public void unsubscribeFromProjectChannel(WsSessionIdentifier sessionId, Long projectId) {
<span class="nc" id="L197">        logger.debug(&quot;Session {} want to unsubscribe from Project#{}&quot;, sessionId, projectId);</span>
<span class="nc" id="L198">        Project project = projectDao.getProject(projectId);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (project != null) {</span>
<span class="nc" id="L200">            securityFacade.assertIsMember(project);</span>
<span class="nc" id="L201">            SubscriptionRequest request = SubscriptionRequest.build(</span>
                SubscriptionRequest.SubscriptionType.UNSUBSCRIBE,
                SubscriptionRequest.ChannelType.PROJECT,
<span class="nc" id="L204">                project.getId(),</span>
<span class="nc" id="L205">                sessionId.getSessionId(),</span>
<span class="nc" id="L206">                requestManager.getHttpSession().getSessionId());</span>
<span class="nc" id="L207">            subscriptionEvents.fire(request);</span>
<span class="nc" id="L208">        } else {</span>
<span class="nc" id="L209">            throw HttpErrorMessage.notFound();</span>
        }

<span class="nc" id="L212">    }</span>

    /**
     * Process subscription request
     *
     * @param request the subscription request
     */
    public void processSubscription(
        @Observes @Inbound(eventName = WS_SUBSCRIPTION_EVENT_CHANNEL) SubscriptionRequest request) {
<span class="nc" id="L221">        logger.debug(&quot;Channel subscription request: {}&quot;, request);</span>
<span class="nc" id="L222">        Session session = WebsocketEndpoint.getSession(request.getWsSessionId());</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (session != null) {</span>
<span class="nc" id="L224">            logger.debug(&quot;Process channel subscription request: {}&quot;, request);</span>

            // first determine the effective channel
<span class="nc" id="L227">            WebsocketEffectiveChannel channel = getChannel(request);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if (channel != null) {</span>
                // make sure the http session has its own set of wsSessions
<span class="nc bnc" id="L230" title="All 2 branches missed.">                if (!httpSessionToWsSessions.containsKey(request.getColabSessionId())) {</span>
<span class="nc" id="L231">                    httpSessionToWsSessions.put(request.getColabSessionId(), new HashSet&lt;&gt;());</span>
                }
                // and  make sure the websocket session is linked to the http session
<span class="nc" id="L234">                httpSessionToWsSessions.get(request.getColabSessionId()).add(session);</span>

                // make sure to link wsSession to its Http session
<span class="nc" id="L237">                wsSessionToHttpSession.put(session, request.getColabSessionId());</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">                if (request.getType() == SubscriptionRequest.SubscriptionType.SUBSCRIBE) {</span>
                    // make sure the http session has its own list of channels
<span class="nc bnc" id="L241" title="All 2 branches missed.">                    if (!wsSessionMap.containsKey(session)) {</span>
<span class="nc" id="L242">                        wsSessionMap.put(session, new HashSet&lt;&gt;());</span>
                    }
                    // keep wsSession to channel registry up-to date
<span class="nc" id="L245">                    wsSessionMap.get(session).add(channel);</span>

                    // subscribe to channel
<span class="nc" id="L248">                    subscribe(channel, session);</span>
                } else {
                    // Remove the channel from the set of channel linked to the wsSession
<span class="nc bnc" id="L251" title="All 2 branches missed.">                    if (wsSessionMap.containsKey(session)) {</span>
<span class="nc" id="L252">                        Set&lt;WebsocketEffectiveChannel&gt; channels = wsSessionMap.get(session);</span>
<span class="nc" id="L253">                        channels.remove(channel);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                        if (channels.isEmpty()) {</span>
<span class="nc" id="L255">                            wsSessionMap.remove(session);</span>
                        }
                    }
<span class="nc" id="L258">                    unsubscribe(channel, Set.of(session));</span>
                }
            } else {
<span class="nc" id="L261">                logger.debug(&quot;Failed to resolve {} to an effective channel&quot;, request);</span>
            }
<span class="nc" id="L263">        } else {</span>
<span class="nc" id="L264">            logger.debug(&quot;Ignore channel subscription: {}&quot;, request);</span>
        }
<span class="nc" id="L266">    }</span>

    /**
     * Add the given session to the set identified by the given channel, in the given map.
     *
     * @param map     map which contains sets
     * @param keyId   set id
     * @param session session to remove from the set
     */
    private void subscribe(WebsocketEffectiveChannel channel, Session session) {
<span class="nc" id="L276">        logger.debug(&quot;Session {} subscribes to {}&quot;, session.getId(), channel);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (!subscriptions.containsKey(channel)) {</span>
<span class="nc" id="L278">            subscriptions.put(channel, new HashSet&lt;&gt;());</span>
        }
<span class="nc" id="L280">        subscriptions.get(channel).add(session);</span>
<span class="nc" id="L281">    }</span>

    /**
     * Unsubscribe all sessions from given channel. If the channel is empty after the operation, it
     * will be destroyed.
     *
     * @param channel  chanel to update
     * @param sessions session to remove from channel
     */
    private void unsubscribe(WebsocketEffectiveChannel channel, Set&lt;Session&gt; sessions) {
<span class="nc" id="L291">        Set&lt;Session&gt; chSessions = subscriptions.get(channel);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L293">            logger.debug(&quot;Sessions {} unsubscribes from {}&quot;, sessions.stream().map(session -&gt; session.getId()), channel);</span>
        }
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (chSessions != null) {</span>
<span class="nc" id="L296">            chSessions.removeAll(sessions);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (chSessions.isEmpty()) {</span>
<span class="nc" id="L298">                subscriptions.remove(channel);</span>
            }
        }
<span class="nc" id="L301">    }</span>

    /**
     * Determine the EffectiveChannel
     *
     * @param request the request
     *
     * @return the channel which match the request
     */
    private WebsocketEffectiveChannel getChannel(SubscriptionRequest request) {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (request.getChannelType() == SubscriptionRequest.ChannelType.PROJECT) {</span>
<span class="nc" id="L312">            Project project = projectDao.getProject(request.getChannelId());</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (project != null) {</span>
<span class="nc" id="L314">                return ProjectContentChannel.build(project);</span>
            }
<span class="nc bnc" id="L316" title="All 2 branches missed.">        } else if (request.getChannelType() == SubscriptionRequest.ChannelType.USER) {</span>
<span class="nc" id="L317">            User user = userDao.findUser(request.getChannelId());</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if (user != null) {</span>
<span class="nc" id="L319">                return user.getEffectiveChannel();</span>
            }
        }

        // not found...
<span class="nc" id="L324">        return null;</span>
    }

    /**
     * Propagate precomputed message to clients. Actually, this methods, will ask all instances of
     * the hazelcast cluster to propagate the message to session they're in charge. This will call
     * {@link #onMessagePropagation(PrecomputedWsMessages) onMessagePropagation}cluster-wide.
     *
     * @param message precomputed message to propagate.
     */
    public void propagate(PrecomputedWsMessages message) {
<span class="nc" id="L335">        this.messagePropagation.fire(message);</span>
<span class="nc" id="L336">    }</span>

    /**
     * On Hazelcast event. Each instance receive precomputed message.
     *
     *
     * @param payload the messagesByChannels to send to clients though relevant websocket channels
     */
    public void onMessagePropagation(
        @Observes @Inbound(eventName = WS_PROPAGATION_CHANNEL) PrecomputedWsMessages payload) {

<span class="nc" id="L347">        Map&lt;WebsocketEffectiveChannel, List&lt;String&gt;&gt; messagesByChannels = payload.getMessages();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (messagesByChannels != null) {</span>
<span class="nc" id="L349">            messagesByChannels.forEach((channel, messages) -&gt; {</span>
<span class="nc" id="L350">                Set&lt;Session&gt; subscribers = this.subscriptions.get(channel);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (subscribers != null) {</span>
<span class="nc" id="L352">                    subscribers.forEach(session -&gt; {</span>
<span class="nc" id="L353">                        messages.forEach(message -&gt; {</span>
                            try {
<span class="nc" id="L355">                                session.getBasicRemote().sendText(message);</span>
<span class="nc" id="L356">                            } catch (IOException ex) {</span>
<span class="nc" id="L357">                                logger.error(&quot;Failed to send websocket message {} to {}&quot;,</span>
                                    message, session);
<span class="nc" id="L359">                            }</span>
<span class="nc" id="L360">                        });</span>
<span class="nc" id="L361">                    });</span>
                }
<span class="nc" id="L363">            });</span>
        }
<span class="nc" id="L365">    }</span>

    /**
     * Unsubscribe all channel linked to the given httpSessionId. This is required after the user
     * sign out.
     *
     * @param httpSessionId httpSessionId which just sign out
     */
    public void signoutAndUnsubscribeFromAll(String httpSessionId) {
        // TODO send logout event, so each client (each browser tab) knows it has been disconected
<span class="nc" id="L375">        Set&lt;Session&gt; wsSessions = this.httpSessionToWsSessions.get(httpSessionId);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (wsSessions != null) {</span>
            // the http session is linked to one or more websocket session, let's cancel all their
            // subscriptions
<span class="nc" id="L379">            wsSessions.stream()</span>
                // get channels from each wsSession
<span class="nc" id="L381">                .map(wsSession -&gt; this.wsSessionMap.get(wsSession))</span>
                // filter out null channels set
<span class="nc bnc" id="L383" title="All 2 branches missed.">                .filter(channels -&gt; channels != null)</span>
                // convert &quot;stream of set of channels&quot; to &quot;stream of channels&quot;
<span class="nc" id="L385">                .flatMap(Collection::stream)</span>
                // no need to list same channel twise
<span class="nc" id="L387">                .distinct()</span>
                // clean subscriptions
<span class="nc" id="L389">                .forEach(channel -&gt; {</span>
<span class="nc" id="L390">                    this.unsubscribe(channel, wsSessions);</span>
<span class="nc" id="L391">                });</span>
        }

<span class="nc" id="L394">        this.httpSessionToWsSessions.remove(httpSessionId);</span>
<span class="nc" id="L395">    }</span>

    /**
     * Clean subscription on session close
     *
     * @param session websocket session to clean subscription for
     */
    public void unsubscribeFromAll(Session session) {
<span class="nc" id="L403">        Set&lt;WebsocketEffectiveChannel&gt; set = this.wsSessionMap.get(session);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (set != null) {</span>
<span class="nc" id="L405">            Set&lt;Session&gt; setOfSession = Set.of(session);</span>
<span class="nc" id="L406">            set.forEach(channel -&gt; {</span>
<span class="nc" id="L407">                unsubscribe(channel, setOfSession);</span>
<span class="nc" id="L408">            });</span>
<span class="nc" id="L409">            this.wsSessionMap.remove(session);</span>
        }
<span class="nc" id="L411">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>