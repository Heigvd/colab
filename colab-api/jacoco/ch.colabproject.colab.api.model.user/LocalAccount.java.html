<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalAccount.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.model.user</a> &gt; <span class="el_source">LocalAccount.java</span></div><h1>LocalAccount.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.model.user;

import ch.colabproject.colab.api.Helper;
import ch.colabproject.colab.api.exceptions.ColabMergeException;
import ch.colabproject.colab.api.model.ColabEntity;
import javax.json.bind.annotation.JsonbTransient;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.Index;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.validation.constraints.NotNull;

/**
 * Password based authentication.
 *
 * @author maxence
 */
@Entity
@NamedQuery(name = &quot;LocalAccount.findByEmail&quot;,
    query = &quot;SELECT a from LocalAccount a where a.email = :email&quot;)
@Table(
    indexes = {
        @Index(columnList = &quot;email&quot;, unique = true)
    })
<span class="fc" id="L34">public class LocalAccount extends Account {</span>

    private static final long serialVersionUID = 1L;

    /**
     * username-like email address
     */
    @NotNull
    private String email;

    /**
     * salt+password hash. Hashed with currentDbHashMethod and dbSalt.
     */
    @JsonbTransient
    @NotNull
    private byte[] hashedPassword;

    /**
     * Has the email address been verified with a VerificationToken ?
     */
    private boolean verified;

    /**
     * Salt to used before hashing the password
     */
    @JsonbTransient
    @NotNull
    private byte[] dbSalt;

    /**
     * Hash method to use to hashedPassword the salt+password
     */
    @Column(length = 100)
    @Enumerated(value = EnumType.STRING)
    @JsonbTransient
    @NotNull
    private HashMethod currentDbHashMethod;

    /**
     * New hash method to use to hash the salt+password. If not null, rotate hash method on next
     * successful authentication
     */
    @Column(length = 100)
    @Enumerated(value = EnumType.STRING)
    @JsonbTransient
    private HashMethod nextDbHashMethod;

    /**
     * Salt the client shall use to before hashing its password. Salt is hex-encoded byte array
     */
    @NotNull
    @JsonbTransient
    private String clientSalt;

    /**
     * New salt the client shall use to prefix its password before hashing it.
     * &lt;p&gt;
     * In case this is not null, client shall send two hashes. First one is the plain_password
     * prefixed with clientSalt and hashed with currentClientHashMethod (to authenticate), second is
     * its password prefixed with this new salt and hashed with nextClientHashMethod if set, current
     * otherwise. successful authentication (to rotate salt and/or method)
     */
    @JsonbTransient
    private String newClientSalt;

    /**
     * Hash method the client shall use to hashedPassword the clientSalt+plain_password
     */
    @Column(length = 100)
    @Enumerated(value = EnumType.STRING)
    @NotNull
    @JsonbTransient
    private HashMethod currentClientHashMethod;

    /**
     * New hash method the client shall use to hash its clientSalt+plain_password.
     * &lt;p&gt;
     * In case this is not null, client shall send two hashes. First one is its plain_password
     * prefixed clientSalt and hashed with currentClientHashMethod (to authenticate), second is its
     * password prefixed with the new_salt (if set)or the current salt and hashed with this method
     */
    @Column(length = 100)
    @Enumerated(value = EnumType.STRING)
    @JsonbTransient
    private HashMethod nextClientHashMethod;

    /**
     *
     * @return email associated with this account
     */
    public String getEmail() {
<span class="fc" id="L125">        return email;</span>
    }

    /**
     * update email. If the email is not the same, this account will not be verified any longer
     *
     * @param email new email to use.
     */
    public void setEmail(String email) {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (Helper.isEmailAddress(email)) {</span>

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (!email.equals(this.email)) {</span>
<span class="fc" id="L137">                this.verified = false;</span>
            }
<span class="fc" id="L139">            this.email = email;</span>
        }
<span class="fc" id="L141">    }</span>

    /**
     * get the stored hashedPassword to challenge authentication against
     *
     * @return hashedPassword hashedPassword to challenge authentication against
     */
    public byte[] getHashedPassword() {
<span class="fc" id="L149">        return hashedPassword;</span>
    }

    /**
     * Update hashedPassword
     *
     * @param hashedPassword new hashedPassword
     */
    public void setHashedPassword(byte[] hashedPassword) {
<span class="fc" id="L158">        this.hashedPassword = hashedPassword;</span>
<span class="fc" id="L159">    }</span>

    /**
     * has the email address been verified ?
     *
     * @return true if the account is verified
     */
    public boolean isVerified() {
<span class="fc" id="L167">        return verified;</span>
    }

    /**
     * Set if the account has been verified or not
     *
     * @param verified yes or no ?
     */
    public void setVerified(boolean verified) {
<span class="fc" id="L176">        this.verified = verified;</span>
<span class="fc" id="L177">    }</span>

    /**
     * @return the salt to used server-side
     */
    public byte[] getDbSalt() {
<span class="fc" id="L183">        return dbSalt;</span>
    }

    /**
     * Update the server-side hashedPassword
     *
     * @param dbSalt new server-side salt
     */
    public void setDbSalt(byte[] dbSalt) {
<span class="fc" id="L192">        this.dbSalt = dbSalt;</span>
<span class="fc" id="L193">    }</span>

    /**
     *
     * @return the current hashedPassword method to used to hashedPassword provided password
     */
    public HashMethod getCurrentDbHashMethod() {
<span class="fc" id="L200">        return currentDbHashMethod;</span>
    }

    /**
     * Set the method to use to hashedPassword provided password
     *
     * @param currentDbHashMethod hashedPassword method
     */
    public void setCurrentDbHashMethod(HashMethod currentDbHashMethod) {
<span class="fc" id="L209">        this.currentDbHashMethod = currentDbHashMethod;</span>
<span class="fc" id="L210">    }</span>

    /**
     * @return the next hashedPassword method to use. If not null, hashedPassword methods will be
     *         rotated on next authentication
     */
    public HashMethod getNextDbHashMethod() {
<span class="fc" id="L217">        return nextDbHashMethod;</span>
    }

    /**
     * change the next hashedPassword method to used
     *
     * @param nextDbHashMethod next hashedPassword method
     */
    public void setNextDbHashMethod(HashMethod nextDbHashMethod) {
<span class="nc" id="L226">        this.nextDbHashMethod = nextDbHashMethod;</span>
<span class="nc" id="L227">    }</span>

    /**
     * @return the salt the user shall use before client-side plain_password hashedPassword
     */
    public String getClientSalt() {
<span class="fc" id="L233">        return clientSalt;</span>
    }

    /**
     * Update the salt the client shall use
     *
     * @param clientSalt client salt
     */
    public void setClientSalt(String clientSalt) {
<span class="fc" id="L242">        this.clientSalt = clientSalt;</span>
<span class="fc" id="L243">    }</span>

    /**
     * @return the salt to use to rotate authentication
     */
    public String getNewClientSalt() {
<span class="fc" id="L249">        return newClientSalt;</span>
    }

    /**
     * set a next client-side salt
     *
     * @param newClientSalt new salt we want the client to use
     */
    public void setNewClientSalt(String newClientSalt) {
<span class="fc" id="L258">        this.newClientSalt = newClientSalt;</span>
<span class="fc" id="L259">    }</span>

    /**
     * @return the hashedPassword method the client shall use to hashedPassword its
     *         salt+plain_password
     */
    public HashMethod getCurrentClientHashMethod() {
<span class="fc" id="L266">        return currentClientHashMethod;</span>
    }

    /**
     * CHange hashedPassword method the client shall use
     *
     * @param currentClientHashMethod hashedPassword method the client shall use
     */
    public void setCurrentClientHashMethod(HashMethod currentClientHashMethod) {
<span class="fc" id="L275">        this.currentClientHashMethod = currentClientHashMethod;</span>
<span class="fc" id="L276">    }</span>

    /**
     * @return the next hashedPassword method the client shall use
     */
    public HashMethod getNextClientHashMethod() {
<span class="fc" id="L282">        return nextClientHashMethod;</span>
    }

    /**
     * Update the next client-side hashedPassword method
     *
     * @param nextClientHashMethod new next client hashedPassword method
     */
    public void setNextClientHashMethod(HashMethod nextClientHashMethod) {
<span class="fc" id="L291">        this.nextClientHashMethod = nextClientHashMethod;</span>
<span class="fc" id="L292">    }</span>

    @Override
    public void merge(ColabEntity other) throws ColabMergeException {
        // TODO
<span class="nc" id="L297">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>