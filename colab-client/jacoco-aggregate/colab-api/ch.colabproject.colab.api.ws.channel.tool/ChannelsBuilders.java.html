<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ChannelsBuilders.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-client</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.ws.channel.tool</a> &gt; <span class="el_source">ChannelsBuilders.java</span></div><h1>ChannelsBuilders.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.ws.channel.tool;

import ch.colabproject.colab.api.model.card.AbstractCardType;
import ch.colabproject.colab.api.model.project.Project;
import ch.colabproject.colab.api.model.user.Account;
import ch.colabproject.colab.api.model.user.User;
import ch.colabproject.colab.api.persistence.jpa.card.CardTypeDao;
import ch.colabproject.colab.api.persistence.jpa.team.TeamDao;
import ch.colabproject.colab.api.persistence.jpa.user.UserDao;
import ch.colabproject.colab.api.ws.channel.model.BlockChannel;
import ch.colabproject.colab.api.ws.channel.model.BroadcastChannel;
import ch.colabproject.colab.api.ws.channel.model.ProjectContentChannel;
import ch.colabproject.colab.api.ws.channel.model.UserChannel;
import ch.colabproject.colab.api.ws.channel.model.WebsocketChannel;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Compute the channels needed to propagate alteration changes.
 *
 * @author sandra
 */
public final class ChannelsBuilders {

    /**
     * Private constructor prevents instantiation
     */
<span class="nc" id="L35">    private ChannelsBuilders() {</span>
<span class="nc" id="L36">        throw new UnsupportedOperationException(&quot;This is a utility class&quot;);</span>
    }

    /**
     * To determine the channels to use
     */
<span class="nc" id="L42">    public static abstract class ChannelsBuilder {</span>
        /**
         * Determine the channels to use
         *
         * @param userDao     the dao to fetch users
         * @param teamDao     the dao to fetch team members
         * @param cardTypeDao the dao to fetch card type
         *
         * @return all channels to use for propagation
         */
        public Set&lt;WebsocketChannel&gt; computeChannels(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L54">            return build(userDao, teamDao, cardTypeDao);</span>
        }

        /**
         * Determine the channels to use (internal implementation)
         *
         * @param userDao     the dao to fetch users
         * @param teamDao     the dao to fetch the team members
         * @param cardTypeDao the dao to fetch card type
         *
         * @return all channels to use for propagation
         */
        abstract protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao);
    }

    /**
     * When there is no channel
     */
<span class="nc" id="L73">    public static class EmptyChannelBuilder extends ChannelsBuilder {</span>
        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L77">            return Set.of();</span>
        }
    }

    /**
     * To build a block channel
     */
    public static class BlockChannelBuilder extends ChannelsBuilder {
        /** the id of the block */
        private final Long blockId;

        /**
         * Create a builder for a block channel
         *
         * @param blockId the id of the block
         */
<span class="nc" id="L93">        public BlockChannelBuilder(Long blockId) {</span>
<span class="nc" id="L94">            this.blockId = blockId;</span>
<span class="nc" id="L95">        }</span>

        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L100">            return Set.of(BlockChannel.build(blockId));</span>
        }
    }

    /**
     * To build a project content channel
     */
    public static class ProjectContentChannelBuilder extends ChannelsBuilder {
        /** the id of the project */
        private final Long projectId;

        /**
         * Create a builder for a project content channel
         *
         * @param project the project
         */
<span class="nc" id="L116">        public ProjectContentChannelBuilder(Project project) {</span>
<span class="nc" id="L117">            projectId = project.getId();</span>
<span class="nc" id="L118">        }</span>

        /**
         * Create a builder for a project content channel
         *
         * @param projectId id of the project
         */
<span class="nc" id="L125">        public ProjectContentChannelBuilder(Long projectId) {</span>
<span class="nc" id="L126">            this.projectId = projectId;</span>
<span class="nc" id="L127">        }</span>

        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L132">            return Set.of(ProjectContentChannel.build(projectId));</span>
        }
    }

    /**
     * To build all channels needed to propagate a project overview alteration
     */
    public static class AboutProjectOverviewChannelsBuilder extends ChannelsBuilder {
        /** the project */
        private final Project project;

        /**
         * Create a builder for the channels to use when a project overview data is changed
         *
         * @param project the project
         */
<span class="nc" id="L148">        public AboutProjectOverviewChannelsBuilder(Project project) {</span>
<span class="nc" id="L149">            this.project = project;</span>
<span class="nc" id="L150">        }</span>

        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L155">            Set&lt;WebsocketChannel&gt; channels = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (project != null) {</span>
<span class="nc" id="L158">                channels.addAll(buildTeammemberChannels(this.project));</span>

<span class="nc" id="L160">                channels.addAll(buildAdminChannels(userDao));</span>
            }

<span class="nc" id="L163">            return channels;</span>
        }
    }

    /**
     * To build a channel for each admin
     */
<span class="nc" id="L170">    public static class ForAdminChannelsBuilder extends ChannelsBuilder {</span>

        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L175">            return buildAdminChannels(userDao);</span>
        }
    }

    /**
     * To build all channels needed to propagate a user alteration
     */
    public static class AboutUserChannelsBuilder extends ChannelsBuilder {
        /** the user */
        private final User user;

        /**
         * Create a builder for the channels to use when a user is changed
         *
         * @param user the user
         */
<span class="nc" id="L191">        public AboutUserChannelsBuilder(User user) {</span>
<span class="nc" id="L192">            this.user = user;</span>
<span class="nc" id="L193">        }</span>

        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L198">            Set&lt;WebsocketChannel&gt; channels = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (user != null) {</span>
<span class="nc" id="L201">                channels.add(UserChannel.build(user));</span>

<span class="nc" id="L203">                channels.addAll(buildTeammatesChannels(user, teamDao));</span>

<span class="nc" id="L205">                channels.addAll(buildAdminChannels(userDao));</span>
            }

<span class="nc" id="L208">            return channels;</span>
        }
    }

    /**
     * To build all channels needed to propagate an account alteration
     */
    public static class AboutAccountChannelsBuilder extends ChannelsBuilder {
        /** the account */
        private final Account account;

        /**
         * Create a builder for the channels to use when an account is changed
         *
         * @param account the account
         */
<span class="nc" id="L224">        public AboutAccountChannelsBuilder(Account account) {</span>
<span class="nc" id="L225">            this.account = account;</span>
<span class="nc" id="L226">        }</span>

        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L231">            Set&lt;WebsocketChannel&gt; channels = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (account.getUser() != null) {</span>
<span class="nc" id="L234">                channels.add(UserChannel.build(account.getUser()));</span>
            }

<span class="nc" id="L237">            channels.addAll(buildAdminChannels(userDao));</span>

<span class="nc" id="L239">            return channels;</span>
        }
    }

    /**
     * To build all channels needed for a card type belonging to a project
     */
    public static class AboutCardTypeChannelsBuilder extends ChannelsBuilder {
        /** the card type */
        private final AbstractCardType cardType;

        /**
         * Create a channel builder for everything needed for a card type belonging to a project
         *
         * @param cardType the card type
         */
<span class="nc" id="L255">        public AboutCardTypeChannelsBuilder(AbstractCardType cardType) {</span>
<span class="nc" id="L256">            this.cardType = cardType;</span>
<span class="nc" id="L257">        }</span>

        @Override
        protected Set&lt;WebsocketChannel&gt; build(UserDao userDao, TeamDao teamDao,
            CardTypeDao cardTypeDao) {
<span class="nc" id="L262">            return buildCardTypeInProjectChannel(cardType, userDao, cardTypeDao);</span>
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers

    /**
     * Build a channel for each admin
     *
     * @param userDao To fetch the admin
     *
     * @return a set of channels : one user channel for each admin
     */
    private static Set&lt;WebsocketChannel&gt; buildAdminChannels(UserDao userDao) {
<span class="nc" id="L277">        return userDao.findAllAdmin().stream()</span>
<span class="nc" id="L278">            .map(user -&gt; UserChannel.build(user))</span>
<span class="nc" id="L279">            .collect(Collectors.toSet());</span>
    }

    /**
     * Build a channel for each team mates of the user
     *
     * @param user the user
     *
     * @return a set of channels : one user channel for each team member of each project
     */
    private static Set&lt;WebsocketChannel&gt; buildTeammatesChannels(User user, TeamDao teamDao) {
<span class="nc" id="L290">        Set&lt;WebsocketChannel&gt; channels = new HashSet&lt;&gt;();</span>

<span class="nc" id="L292">        teamDao.findMemberByUser(user).forEach(member -&gt; {</span>
<span class="nc" id="L293">            channels.addAll(buildTeammemberChannels(member.getProject()));</span>
<span class="nc" id="L294">        });</span>

<span class="nc" id="L296">        return channels;</span>
    }

    /**
     * Build a channel for each team member of the project
     *
     * @param project the project
     *
     * @return a set of user channels : one for each team member
     */
    private static Set&lt;WebsocketChannel&gt; buildTeammemberChannels(Project project) {
<span class="nc" id="L307">        return project.getTeamMembers().stream()</span>
            // filter out pending invitation
<span class="nc bnc" id="L309" title="All 2 branches missed.">            .filter(member -&gt; member.getUser() != null)</span>
<span class="nc" id="L310">            .map(member -&gt; UserChannel.build(member.getUser()))</span>
<span class="nc" id="L311">            .collect(Collectors.toSet());</span>
    }

    /**
     * Build all channels needed when a card type is changed
     *
     * @param cardType    the card type
     * @param userDao     to fetch the admin
     * @param cardTypeDao to fetch the references of a card type
     *
     * @return
     */
    private static Set&lt;WebsocketChannel&gt; buildCardTypeInProjectChannel(
        AbstractCardType cardType, UserDao userDao,
        CardTypeDao cardTypeDao) {
<span class="nc" id="L326">        Set&lt;WebsocketChannel&gt; channels = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (cardType.getProject() != null) {</span>
            // this type belongs to a specific project
            // first, everyone who is editing the project shall receive updates
<span class="nc" id="L331">            channels.add(ProjectContentChannel.build(cardType.getProject()));</span>

<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (cardType.isOrWasPublished()) {</span>
                // eventually, published types are available to each project members
                // independently of the project they're editing
<span class="nc" id="L336">                channels.addAll(buildTeammemberChannels(cardType.getProject()));</span>
            }

            // then, the type must be propagated to all projects which reference it
<span class="nc" id="L340">            cardTypeDao.findDirectReferences(cardType).forEach(ref -&gt; {</span>
<span class="nc" id="L341">                channels.addAll(buildCardTypeInProjectChannel(ref, userDao, cardTypeDao));</span>
<span class="nc" id="L342">            });</span>
        } else {
            // This is a global type
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (cardType.isOrWasPublished()) {</span>
                // As the type is published, everyone may use this type -&gt; broadcast
<span class="nc" id="L347">                channels.add(BroadcastChannel.build());</span>
            } else {
                // Not published type are only available to admin
<span class="nc" id="L350">                channels.addAll(buildAdminChannels(userDao));</span>
            }
        }

<span class="nc" id="L354">        return channels;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>