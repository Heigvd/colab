<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LiveUpdates.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-client</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.microchanges.live</a> &gt; <span class="el_source">LiveUpdates.java</span></div><h1>LiveUpdates.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.microchanges.live;

import ch.colabproject.colab.api.microchanges.model.Change;
import ch.colabproject.colab.api.microchanges.model.MicroChange;
import ch.colabproject.colab.api.microchanges.model.MicroChange.Type;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.apache.commons.text.StringEscapeUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Set of pending changes.
 *
 * @author maxence
 */
<span class="nc" id="L32">public class LiveUpdates implements Serializable {</span>

    private static final long serialVersionUID = 1L;

    /** Logger */
<span class="nc" id="L37">    private static final Logger logger = LoggerFactory.getLogger(LiveUpdates.class);</span>

    /**
     * JsonDiscriminator to fetch the class this change targets
     */
    private String targetClass;

    /**
     * Id of the object this change targets
     */
    private Long targetId;

    /**
     * initial revision of content
     */
    private String revision;

    /**
     * root content
     */
    private String content;

    /**
     * List of pending changes
     */
<span class="nc" id="L62">    private List&lt;Change&gt; pendingChanges = new ArrayList&lt;&gt;();</span>

    /**
     * Temp debug data
     */
<span class="nc" id="L67">    private transient String debugData = null;</span>

    /**
     * Get the JSON discriminator
     *
     * @return JSON discriminator
     */
    public String getTargetClass() {
<span class="nc" id="L75">        return targetClass;</span>
    }

    /**
     * Set the JSON discriminator
     *
     * @param targetClass new discriminator
     */
    public void setTargetClass(String targetClass) {
<span class="nc" id="L84">        this.targetClass = targetClass;</span>
<span class="nc" id="L85">    }</span>

    /**
     * The object id.
     *
     * @return the id of the object
     */
    public Long getTargetId() {
<span class="nc" id="L93">        return targetId;</span>
    }

    /**
     * set object id
     *
     * @param targetId object id
     */
    public void setTargetId(Long targetId) {
<span class="nc" id="L102">        this.targetId = targetId;</span>
<span class="nc" id="L103">    }</span>

    /**
     * Get the revision
     *
     * @return the revision
     */
    public String getRevision() {
<span class="nc" id="L111">        return revision;</span>
    }

    /**
     * Set the revision
     *
     * @param revision the revision
     */
    public void setRevision(String revision) {
<span class="nc" id="L120">        this.revision = revision;</span>
<span class="nc" id="L121">    }</span>

    /**
     * Get initial &quot;root&quot; content
     *
     * @return the root content
     */
    public String getContent() {
<span class="nc" id="L129">        return content;</span>
    }

    /**
     * Set initial content
     *
     * @param content the content
     */
    public void setContent(String content) {
<span class="nc" id="L138">        this.content = content;</span>
<span class="nc" id="L139">    }</span>

    /**
     * Get the list of pending changes
     *
     * @return changes
     */
    public List&lt;Change&gt; getPendingChanges() {
<span class="nc" id="L147">        return pendingChanges;</span>
    }

    /**
     * set the list of pending changes
     *
     * @param pendingChanges changes
     */
    public void setPendingChanges(List&lt;Change&gt; pendingChanges) {
<span class="nc" id="L156">        this.pendingChanges = pendingChanges;</span>
<span class="nc" id="L157">    }</span>

    /**
     * Get change by revision
     *
     * @param changes  all changes
     * @param revision the revision tag
     *
     * @return the change which the given revision or null if such a change does not exist
     */
    public Change getByRevision(List&lt;Change&gt; changes, String revision) {
<span class="nc" id="L168">        Optional&lt;Change&gt; findAny = changes.stream()</span>
<span class="nc" id="L169">            .filter(ch -&gt; ch.getRevision().equals(revision))</span>
<span class="nc" id="L170">            .findAny();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        return findAny.isPresent() ? findAny.get() : null;</span>
    }

    /**
     * Get changes which are direct children of given parent
     *
     * @param changes all changes
     * @param basedOn parent id
     *
     * @return all changes which are based on the given parentId
     */
    public List&lt;Change&gt; getByParent(List&lt;Change&gt; changes, String basedOn) {
<span class="nc" id="L183">        List&lt;Change&gt; collect = changes.stream()</span>
<span class="nc" id="L184">            .filter(ch -&gt; ch.getBasedOn().contains(basedOn))</span>
<span class="nc" id="L185">            .collect(Collectors.toList());</span>
<span class="nc" id="L186">        return new ArrayList&lt;&gt;(collect);</span>
    }

    /**
     * Get changes which are direct children of the given parent, authored by the same live-session.
     * This method is used to detect if a live session has diverged.
     *
     * @param changes list of changes
     * @param parent  parent
     *
     * @return children of parent if they are authored by the same person
     */
    public List&lt;Change&gt; getByParentAndSession(List&lt;Change&gt; changes, Change parent) {
<span class="nc" id="L199">        logger.trace(&quot;Get Children By Parent And Session&quot;);</span>

<span class="nc" id="L201">        List&lt;Change&gt; collect = changes.stream()</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            .filter(ch -&gt; ch.getBasedOn().contains(parent.getRevision())</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            &amp;&amp; ch.getLiveSession().equals(parent.getLiveSession()))</span>
<span class="nc" id="L204">            .collect(Collectors.toList());</span>
<span class="nc" id="L205">        return new ArrayList&lt;&gt;(collect);</span>
    }

    /**
     * Include new offset within the map.
     *
     * @param offsets offsets mapped by indexes
     * @param index   new offset index
     * @param value   new offset value
     */
    private void modifyOffset(Map&lt;Integer, Integer&gt; offsets, Integer index, Integer value) {
<span class="nc" id="L216">        Integer currentOffset = offsets.get(index);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (currentOffset == null) {</span>
<span class="nc" id="L218">            currentOffset = 0;</span>
        }
<span class="nc" id="L220">        currentOffset += value;</span>
<span class="nc" id="L221">        logger.trace(&quot;  modOffset.start &quot; + offsets);</span>

<span class="nc" id="L223">        offsets.put(index, currentOffset);</span>

//        logger.trace(&quot;  modOffset.second &quot; + offsets);
//
//        Map&lt;Integer, Integer&gt; modified = new HashMap&lt;&gt;();
//
//        // shift offsets after current index
//        offsets.entrySet().forEach(entry -&gt; {
//            Integer key = entry.getKey();
//            if (key &gt; index &amp;&amp; key &lt; index + value) {
//                logger.trace(&quot;CONFLIT&quot;);
//            }
//            if (key &gt; index) {
//                // move offset to new index
//                Integer v = entry.getValue();
//                if (v != null) {
//                    int newKey = key + value;
//                    int newValue = v;
//                    if (offsets.containsKey(newKey)) {
//                        newValue = offsets.get(newKey) + newValue;
//                    }
//                    modified.put(key, 0);
//                    modified.put(newKey, newValue);
//                }
//            }
//        });
//
//        logger.trace(&quot;  modOffset.third &quot; + modified);
//
//        // merge shifted offsets
//        modified.entrySet().forEach(entry -&gt; {
//            Integer key = entry.getKey();
//            int current = entry.getValue();
//            offsets.put(key, current);
//        });
//
//        logger.trace(&quot; mod Offsets.done &quot; + offsets);
<span class="nc" id="L260">    }</span>

    /**
     * Apply microchange to the buffer
     *
     * @param buffer the buffet
     * @param mu     the patch
     */
    private void applyChange(StringBuilder buffer, MicroChange mu) {
<span class="nc" id="L269">        logger.trace(&quot;Apply {} to {}&quot;, mu, buffer);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (mu.getT() == MicroChange.Type.D) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (mu.getO() &lt; buffer.length()) {</span>
<span class="nc" id="L272">                buffer.length();</span>
<span class="nc" id="L273">                buffer.delete(mu.getO(), mu.getO() + mu.getL());</span>
            } else {
<span class="nc" id="L275">                logger.trace(&quot;Skip micro change&quot;);</span>
            }
<span class="nc bnc" id="L277" title="All 2 branches missed.">        } else if (mu.getT() == MicroChange.Type.I) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (mu.getO() &gt;= buffer.length()) {</span>
<span class="nc" id="L279">                buffer.append(mu.getV());</span>
            } else {
<span class="nc" id="L281">                buffer.insert(mu.getO(), mu.getV());</span>
            }
        }
<span class="nc" id="L284">    }</span>

    /**
     * Compute offset the set of microchanges will generate.
     * &lt;li&gt;2:20 means 20 characters are added at index 2
     * &lt;li&gt;5:-10 means 10 characters are removed from index 5
     *
     * @param change set of microchanges
     *
     * @return offset mapped by index
     */
    private Map&lt;Integer, Integer&gt; computeOffset(Change change) {
<span class="nc" id="L296">        Map&lt;Integer, Integer&gt; offsets = new HashMap&lt;&gt;();</span>

<span class="nc" id="L298">        List&lt;MicroChange&gt; muChanges = change.getMicrochanges();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (int i = muChanges.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L300">            MicroChange mu = muChanges.get(i);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (mu.getT() == MicroChange.Type.D) {</span>
<span class="nc" id="L302">                modifyOffset(offsets, mu.getO() + mu.getL(), -mu.getL());</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            } else if (mu.getT() == MicroChange.Type.I) {</span>
<span class="nc" id="L304">                modifyOffset(offsets, mu.getO(), mu.getV().length());</span>
            }
        }

<span class="nc" id="L308">        return offsets;</span>
    }

    /**
     * Modify microchange to reflect given offsets
     *
     * @param change  changes to update
     * @param offsets offsets, mapped by indexes
     * @param forward shif if true, unshift otherwise
     *
     * @return true if operation was successful, false if there ws some conflict
     */
    private boolean shift(Change change, Map&lt;Integer, Integer&gt; offsets, boolean forward) {
<span class="nc" id="L321">        boolean conflictFree = true;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (forward == false) {</span>
<span class="nc" id="L323">            logger.warn(&quot;TODO: implement backward shift&quot;);</span>
        }
        //int way = forward ? 1 : -1; // TODO

<span class="nc" id="L327">        logger.trace(&quot;Shift offsets: {}&quot;, change);</span>
<span class="nc" id="L328">        List&lt;MicroChange&gt; microchanges = change.getMicrochanges();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (int i = 0; i &lt; microchanges.size(); i++) {</span>
<span class="nc" id="L330">            MicroChange mu = microchanges.get(i);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (Map.Entry&lt;Integer, Integer&gt; entry : offsets.entrySet()) {</span>
<span class="nc" id="L333">                Integer offsetValue = entry.getValue();</span>
<span class="nc" id="L334">                Integer offsetIndex = entry.getKey();</span>

<span class="nc" id="L336">                int muStart = mu.getO();</span>

<span class="nc bnc" id="L338" title="All 4 branches missed.">                if (offsetValue &gt; 0 &amp;&amp; mu.getT().equals(Type.I)) {</span>
                    // both are insetion
<span class="nc bnc" id="L340" title="All 2 branches missed.">                    if (mu.getO() &gt;= offsetIndex) {</span>
                        // changes is after the first insertion =&gt; shift it
<span class="nc" id="L342">                        mu.setO(mu.getO() + offsetValue);</span>
                    }
<span class="nc bnc" id="L344" title="All 4 branches missed.">                } else if (offsetValue &lt; 0 &amp;&amp; mu.getT().equals(Type.D)) {</span>
                    // both are deletion
<span class="nc" id="L346">                    int deleteFromIndex = offsetIndex + offsetValue;</span>
<span class="nc" id="L347">                    int deleteToIndex = offsetIndex;</span>
<span class="nc" id="L348">                    int muEnd = muStart + mu.getL();</span>

                    // nothing to do if mu is complely before offset
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (muEnd &gt;= deleteFromIndex) {</span>
                        // mu is completely before offset
                        // nothing to do
<span class="nc bnc" id="L354" title="All 2 branches missed.">                        if (muStart &gt; deleteToIndex) {</span>
                            // mu is completely after offset
                            // just shift mu
<span class="nc" id="L357">                            mu.setO(mu.getO() + offsetValue);</span>
                        } else {
                            // deletions overlap
<span class="nc bnc" id="L360" title="All 4 branches missed.">                            if (muStart &lt;= deleteFromIndex &amp;&amp; muEnd &gt;= deleteToIndex) {</span>
                                // mu wraps offset
                                // off          |---|
                                // mu       |---------|
                                // new mu   |---     -|
<span class="nc" id="L365">                                mu.setL(mu.getL() + offsetValue);</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">                            } else if (muStart &gt;= deleteFromIndex &amp;&amp; muEnd &lt;= deleteToIndex) {</span>
                                // offset wraps mu =&gt; mus is useless
                                // off       |---------|
                                // mu          |---|
                                // new mu    canceled
<span class="nc" id="L371">                                microchanges.remove(i);</span>
<span class="nc" id="L372">                                i--;</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">                            } else if (muStart &lt;= deleteFromIndex &amp;&amp; muEnd &lt;= deleteToIndex) {</span>
                                // partial overlap
                                // off       |-----|
                                // mu     |-----|
                                // new mu |--|
<span class="nc" id="L378">                                mu.setL(deleteFromIndex - muStart);</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">                            } else if (muStart &gt;= deleteFromIndex &amp;&amp; muEnd &gt;= deleteToIndex) {</span>
                                // partial overlap
                                // off    |-----|
                                // mu        |-----|
                                // new mu       |--| shifted at offsetStart
<span class="nc" id="L384">                                mu.setL(muEnd - deleteToIndex);</span>
<span class="nc" id="L385">                                mu.setO(deleteFromIndex);</span>
                            } else {
<span class="nc" id="L387">                                logger.error(&quot;Unhandled case offset{}:{}, mu:{}&quot;,</span>
<span class="nc" id="L388">                                    deleteFromIndex, offsetValue, mu);</span>
                            }
                        }
                    }
<span class="nc bnc" id="L392" title="All 4 branches missed.">                } else if (offsetValue &lt; 0 &amp;&amp; mu.getT().equals(Type.I)) {</span>
                    // offset is deletion, mu is addition
<span class="nc" id="L394">                    int deleteFromIndex = offsetIndex + offsetValue;</span>
<span class="nc" id="L395">                    int deleteToIndex = offsetIndex;</span>

<span class="nc bnc" id="L397" title="All 2 branches missed.">                    if (muStart &gt;= deleteToIndex) {</span>
                        // off    |-----|
                        // mu               |+++++|
                        // just shift to the left
<span class="nc" id="L401">                        mu.setO(mu.getO() + offsetValue);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                    } else if (muStart &gt; deleteFromIndex) {</span>
                        // off         |-----|
                        // mu            |+|
                        // mu          |+|
<span class="nc" id="L406">                        mu.setO(deleteFromIndex);</span>
//                    } else {
                        // mu is before offset
                        // off         |-----|
                        // mu     |+|
                        // nothing to do
                    }
<span class="nc bnc" id="L413" title="All 4 branches missed.">                } else if (offsetValue &gt; 0 &amp;&amp; mu.getT().equals(Type.D)) {</span>
                    // offset is addition, mu is deletion
<span class="nc" id="L415">                    int muEnd = muStart + mu.getL();</span>

                    // nothing to do if mu is completely before offset
<span class="nc bnc" id="L418" title="All 2 branches missed.">                    if (muEnd &gt;= offsetIndex) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                        if (muStart &gt; offsetIndex) {</span>
                            // off   |+|
                            // mu         |---|
                            // new mu : shift
<span class="nc" id="L423">                            mu.setO(mu.getO() + offsetValue);</span>
                        } else {
                            // off        |+|
                            // mu      |--------|
                            // new v1  |--|  |--|
                            // split mu to preserve addition
<span class="nc" id="L429">                            Integer totalLength = mu.getL();</span>
<span class="nc" id="L430">                            mu.setL(offsetIndex - muStart);</span>
<span class="nc" id="L431">                            MicroChange newMu = new MicroChange();</span>
<span class="nc" id="L432">                            newMu.setT(Type.D);</span>
<span class="nc" id="L433">                            newMu.setO(offsetIndex + offsetValue);</span>
<span class="nc" id="L434">                            newMu.setL(totalLength - mu.getL());</span>
<span class="nc" id="L435">                            microchanges.add(i + 1, newMu);</span>
<span class="nc" id="L436">                            i++;</span>
                        }
                    }
                }
<span class="nc" id="L440">            }</span>
        }

<span class="nc" id="L443">        logger.trace(</span>
            &quot;Shift done: {}&quot;, change);

<span class="nc" id="L446">        return conflictFree;</span>
    }

    /**
     * Compute shifted offset by reflecting changes.
     *
     * @param offsets original offsets
     * @param change  change
     *
     * @return new map of shifted offsets
     */
    private Map&lt;Integer, Integer&gt; shiftOffsets(Map&lt;Integer, Integer&gt; offsets, Change change) {
<span class="nc" id="L458">        Map&lt;Integer, Integer&gt; shifted = new HashMap&lt;&gt;();</span>

<span class="nc" id="L460">        offsets.entrySet().forEach(entry -&gt; {</span>
<span class="nc" id="L461">            Integer offsetIndex = entry.getKey();</span>
<span class="nc" id="L462">            Integer offsetValue = entry.getValue();</span>

<span class="nc" id="L464">            List&lt;MicroChange&gt; muChanges = change.getMicrochanges();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            for (int i = muChanges.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L466">                MicroChange mu = muChanges.get(i);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                if (mu.getO() &lt;= offsetIndex) {</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                    if (mu.getT() == MicroChange.Type.D) {</span>
<span class="nc" id="L469">                        offsetIndex -= mu.getL();</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                    } else if (mu.getT() == MicroChange.Type.I) {</span>
<span class="nc" id="L471">                        offsetIndex += mu.getV().length();</span>
                    }
                }
            }
<span class="nc" id="L475">            shifted.put(offsetIndex, offsetValue);</span>
<span class="nc" id="L476">        });</span>

<span class="nc" id="L478">        return shifted;</span>
    }

    /**
     * Propagate offset to children
     *
     * @param parent  starting point
     * @param offsets offset to propagate
     *
     * @return conflict free propagation or not
     */
    private boolean propagateOffsets(List&lt;Change&gt; changes, Change parent, Map&lt;Integer, Integer&gt; offsets, boolean forward, String offsetFromRev) {
<span class="nc" id="L490">        boolean conflictFree = true;</span>

<span class="nc bnc" id="L492" title="All 2 branches missed.">        for (Change child : getByParent(changes, parent.getRevision())) {</span>
<span class="nc" id="L493">            Set&lt;String&gt; childDeps = getAllDependencies(changes, child);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            if (!childDeps.contains(offsetFromRev)) {</span>
<span class="nc" id="L495">                logger.trace(&quot;PropagateOffset {}@{} to {}&quot;, offsets, offsetFromRev, child);</span>
                // should propagate to children which are not based on the offsetsFromRev
<span class="nc" id="L497">                boolean shiftFree = this.shift(child, offsets, forward);</span>
<span class="nc" id="L498">                Map&lt;Integer, Integer&gt; shiftedOffsets = shiftOffsets(offsets, child);</span>
<span class="nc" id="L499">                logger.trace(&quot;Shifted Offsets: {}&quot;, shiftedOffsets);</span>
<span class="nc" id="L500">                boolean pFree = this.propagateOffsets(changes, child, shiftedOffsets, forward, offsetFromRev);</span>
<span class="nc bnc" id="L501" title="All 6 branches missed.">                conflictFree = conflictFree &amp;&amp; shiftFree &amp;&amp; pFree;</span>
<span class="nc" id="L502">            } else {</span>
                //merge has been done
<span class="nc" id="L504">                HashSet&lt;String&gt; newDeps = new HashSet&lt;&gt;(child.getBasedOn());</span>
<span class="nc" id="L505">                newDeps.remove(offsetFromRev);</span>
<span class="nc" id="L506">                logger.trace(&quot;Do not go deeper than {}, now based on {}&quot;, child, newDeps);</span>
<span class="nc" id="L507">                child.setBasedOn(newDeps);</span>
                //child.getBasedOn().remove(offsetFromRev);
            }
<span class="nc" id="L510">        }</span>
<span class="nc" id="L511">        return conflictFree;</span>
    }

    /**
     * Get the full set of revision the given change depends on
     *
     * @param changes full set of changes
     * @param change  the change
     *
     * @return set of dependencies
     */
    private Set&lt;String&gt; getAllDependencies(List&lt;Change&gt; changes, Change change) {
<span class="nc" id="L523">        Set&lt;String&gt; deps = new HashSet&lt;&gt;();</span>

<span class="nc" id="L525">        List&lt;Change&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L526">        queue.add(change);</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">        while (!queue.isEmpty()) {</span>
<span class="nc" id="L529">            Change ch = queue.remove(0);</span>
<span class="nc" id="L530">            ch.getBasedOn().forEach(dep -&gt; {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                if (!deps.contains(dep)) {</span>
<span class="nc" id="L532">                    deps.add(dep);</span>
<span class="nc" id="L533">                    Change parent = getByRevision(changes, dep);</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">                    if (parent != null &amp;&amp; !queue.contains(parent)) {</span>
<span class="nc" id="L535">                        queue.add(parent);</span>
                    }
                }
<span class="nc" id="L538">            });</span>
<span class="nc" id="L539">        }</span>

<span class="nc" id="L541">        return deps;</span>
    }

    /**
     * Do sets equals?
     *
     * @param a first set
     * @param b second set
     *
     * @return true if sets equal
     */
    private boolean setsEqual(Set&lt;String&gt; a, Set&lt;String&gt; b) {
<span class="nc bnc" id="L553" title="All 4 branches missed.">        if (a == null &amp;&amp; b == null) {</span>
            // both null equals
<span class="nc" id="L555">            return true;</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">        } else if (a == null || b == null) {</span>
            // only one is null
<span class="nc" id="L558">            return false;</span>
        } else {
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (a.size() != b.size()) {</span>
<span class="nc" id="L561">                return false;</span>
            }
<span class="nc" id="L563">            return a.containsAll(b);</span>
        }
    }

    /**
     * Move a change to a new base.
     *
     * @param newBase
     * @param change
     * @param offsets
     *
     * @return true if rebase has been done without conflict
     */
    private boolean rebase(List&lt;Change&gt; changes, Change newBase, Change change) {
<span class="nc" id="L577">        Set&lt;String&gt; baseDeps = getAllDependencies(changes, newBase);</span>
<span class="nc" id="L578">        Set&lt;String&gt; changeDeps = getAllDependencies(changes, change);</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (setsEqual(baseDeps, changeDeps)) {</span>
            try {
                // exact same set of dependencies: changes are sieblings
<span class="nc" id="L583">                Map&lt;Integer, Integer&gt; offsets = computeOffset(newBase);</span>
<span class="nc" id="L584">                boolean conflictFree = true;</span>
<span class="nc" id="L585">                String newBaseRev = newBase.getRevision();</span>

<span class="nc" id="L587">                logger.trace(&quot;Rebase Sieblings: &quot; + change + &quot; on &quot; + newBase</span>
                    + &quot; with offset &quot; + offsets);

<span class="nc bnc" id="L590" title="All 4 branches missed.">                conflictFree = shift(change, offsets, true) &amp;&amp; conflictFree;</span>
<span class="nc bnc" id="L591" title="All 4 branches missed.">                conflictFree = propagateOffsets(changes, change,</span>
                    offsets, true, newBaseRev) &amp;&amp; conflictFree;

                // Update parents after rebase/propagation step
<span class="nc" id="L595">                change.setBasedOn(Set.of(newBase.getRevision()));</span>
<span class="nc" id="L596">                logger.trace(&quot; -&gt; &quot; + change);</span>
<span class="nc" id="L597">                return conflictFree;</span>
<span class="nc" id="L598">            } catch (StackOverflowError e) {</span>
<span class="nc" id="L599">                logger.warn(&quot;Major issue: fail to propagate offset&quot;);</span>
<span class="nc" id="L600">                printDebugData();</span>
<span class="nc" id="L601">                throw e;</span>
            }
<span class="nc bnc" id="L603" title="All 2 branches missed.">        } else if (setsEqual(Set.of(change.getRevision()), newBase.getBasedOn())) {</span>
<span class="nc" id="L604">            logger.trace(&quot;Inverse hierarchy : &quot; + change + &quot; on &quot; + newBase);</span>
            // [x] -&gt; change -&gt; newBase
            // ==&gt;[x] -&gt;  newBase -&gt; change

<span class="nc" id="L608">            boolean conflictFree = true;</span>

<span class="nc" id="L610">            Map&lt;Integer, Integer&gt; changeOffsets = computeOffset(change);</span>

<span class="nc" id="L612">            newBase.setBasedOn(change.getBasedOn());</span>
<span class="nc" id="L613">            change.setBasedOn(Set.of(newBase.getRevision()));</span>

<span class="nc bnc" id="L615" title="All 4 branches missed.">            conflictFree = shift(newBase, changeOffsets, false) &amp;&amp; conflictFree;</span>

<span class="nc" id="L617">            Map&lt;Integer, Integer&gt; newBaseOffsets = computeOffset(newBase);</span>
<span class="nc bnc" id="L618" title="All 4 branches missed.">            conflictFree = shift(change, newBaseOffsets, true) &amp;&amp; conflictFree;</span>

<span class="nc" id="L620">            logger.trace(&quot; with offsets &quot; + changeOffsets + &quot; and &quot; + newBaseOffsets);</span>
<span class="nc" id="L621">            logger.trace(&quot; -&gt; &quot; + change);</span>

<span class="nc" id="L623">            return conflictFree;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        } else if (changeDeps.containsAll(baseDeps)) {</span>
            // nothing to do as all deps are already known
<span class="nc" id="L626">            logger.trace(&quot;Nothing to do: change includes all base parents&quot;);</span>
<span class="nc" id="L627">            return true;</span>
        } else {
<span class="nc" id="L629">            logger.error(&quot;Not yet implemented: Changes: {} Change: {} NewBase: {} BaseDeps: {} ChangeDeps: {}&quot;, changes, change.getRevision(), newBase.getRevision(), baseDeps, changeDeps);</span>
<span class="nc" id="L630">            return false;</span>
        }
    }

    /**
     * Filter list of change and return only those which match the given live session
     *
     * @param changes list of changes
     * @param author  live-session id
     *
     * @return list of changes authored by the given author
     */
    public List&lt;Change&gt; filterByAuthor(List&lt;Change&gt; changes, String author) {
<span class="nc" id="L643">        return changes.stream()</span>
<span class="nc" id="L644">            .filter(child</span>
<span class="nc" id="L645">                -&gt; child.getLiveSession().equals(author))</span>
<span class="nc" id="L646">            .collect(Collectors.toList());</span>
    }

    private List&lt;String&gt; mapChangesRevision(Collection&lt;Change&gt; changes) {
<span class="nc" id="L650">        return changes.stream().map(Change::getRevision).collect(Collectors.toList());</span>
    }

    /**
     * Apply all changes.
     *
     * @param strict to be implemented: fail when there is some conflicts or not
     *
     * @return up-to date content
     */
    public LiveResult process(boolean strict) {
<span class="nc" id="L661">        initDebugData();</span>
<span class="nc" id="L662">        logger.debug(&quot;Debug Data {}&quot;, this.debugData);</span>

<span class="nc" id="L664">        StringBuilder buffer = new StringBuilder();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (this.content != null) {</span>
<span class="nc" id="L666">            buffer.append(this.content);</span>
        }

<span class="nc" id="L669">        logger.trace(&quot;Process: {}&quot;, this);</span>

<span class="nc" id="L671">        String currentRevision = this.revision;</span>

<span class="nc" id="L673">        List&lt;Change&gt; allChanges = this.getPendingChanges();</span>
<span class="nc" id="L674">        List&lt;Change&gt; changes = new ArrayList&lt;&gt;(allChanges);</span>

<span class="nc" id="L676">        Set&lt;String&gt; appliedChanges = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L678" title="All 2 branches missed.">        while (!changes.isEmpty()) {</span>
<span class="nc" id="L679">            appliedChanges.add(currentRevision);</span>
            // fetch all changes based on the current revision
<span class="nc" id="L681">            List&lt;Change&gt; children = getByParent(changes, currentRevision);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (!children.isEmpty()) {</span>
                //Map&lt;Integer, Integer&gt; offsets = new HashMap&lt;&gt;();
                //logger.trace(&quot;new empty offsets &quot; + offsets);
<span class="nc" id="L685">                logger.trace(&quot;All @{} children: {}&quot;, currentRevision, mapChangesRevision(children));</span>

                // find a child which depends only only already applied changes
                // NB: as I understand the algorithm, I can't figure out a case
                //     such a child-with-unapplied-parent may event exists...
<span class="nc" id="L690">                Optional&lt;Change&gt; optChange = children.stream()</span>
<span class="nc" id="L691">                    .filter(ch -&gt; appliedChanges.containsAll(ch.getBasedOn()))</span>
<span class="nc" id="L692">                    .findFirst();</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                if (optChange.isPresent()) {</span>
<span class="nc" id="L694">                    Change change = optChange.get();</span>
                    // clean lists
<span class="nc" id="L696">                    changes.remove(change);</span>
<span class="nc" id="L697">                    children.remove(change);</span>

<span class="nc" id="L699">                    logger.trace(&quot;Process: {}&quot;, change);</span>

<span class="nc" id="L701">                    List&lt;MicroChange&gt; muChanges = change.getMicrochanges();</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                    for (int i = muChanges.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L703">                        applyChange(buffer, muChanges.get(i));</span>
<span class="nc" id="L704">                        logger.trace(&quot;  &quot; + i + &quot;)&quot; + buffer);</span>
                    }

<span class="nc" id="L707">                    logger.trace(&quot; -&gt; {}&quot;, buffer);</span>
                    // logger.trace(&quot;Offsets&quot; + offsets);
                    // rebase others children

<span class="nc" id="L711">                    changes.removeAll(children);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    for (int i = children.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L713">                        Change child = children.remove(i);</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">                        if (!rebase(allChanges, change, child) &amp;&amp; strict) {</span>
                            // todo throw ?
<span class="nc" id="L716">                            logger.warn(&quot;Conflict&quot;);</span>
                        }
<span class="nc" id="L718">                        changes.add(0, child);</span>
                    }
<span class="nc" id="L720">                    currentRevision = change.getRevision();</span>
<span class="nc" id="L721">                } else {</span>
                    //TODO add full tree JSON formated full tree
<span class="nc" id="L723">                    logger.error(&quot;No child found in {}&quot;, children);</span>
<span class="nc" id="L724">                    printDebugData();</span>
<span class="nc" id="L725">                    break;</span>
                }

<span class="nc" id="L728">            } else {</span>
                //TODO add full tree JSON formated full tree
<span class="nc" id="L730">                logger.error(&quot;Some children without any parents left: {}&quot;, changes);</span>
<span class="nc" id="L731">                printDebugData();</span>
<span class="nc" id="L732">                break;</span>
            }
<span class="nc" id="L734">        }</span>

<span class="nc" id="L736">        return LiveResult.build(buffer.toString(), currentRevision);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L741">        return &quot;LiveUpdates{&quot; + &quot;targetClass=&quot; + targetClass + &quot;, targetId=&quot; + targetId + &quot;, revision=&quot; + revision + &quot;, content=&quot; + content + &quot;, pendingChanges=&quot; + pendingChanges + '}';</span>
    }

    /**
     * Build log message that can be easily used to reproduces the process in a test
     */
    public void initDebugData() {

<span class="nc" id="L749">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L750">        sb.append(&quot;test('A Test', () =&gt; {&quot;)</span>
<span class="nc" id="L751">            .append(System.lineSeparator())</span>
<span class="nc" id="L752">            .append(&quot;const initialValue = \&quot;&quot;)</span>
<span class="nc" id="L753">            .append(StringEscapeUtils.escapeEcmaScript(this.content))</span>
<span class="nc" id="L754">            .append(&quot;\&quot;;&quot;).append(System.lineSeparator())</span>
<span class="nc" id="L755">            .append(&quot;const initialRevision = \&quot;&quot;)</span>
<span class="nc" id="L756">            .append(StringEscapeUtils.escapeEcmaScript(this.revision))</span>
<span class="nc" id="L757">            .append(&quot;\&quot;;&quot;).append(System.lineSeparator())</span>
<span class="nc" id="L758">            .append(System.lineSeparator())</span>
<span class="nc" id="L759">            .append(System.lineSeparator())</span>
<span class="nc" id="L760">            .append(&quot;const changes =[&quot;)</span>
<span class="nc" id="L761">            .append(System.lineSeparator());</span>

<span class="nc" id="L763">        this.pendingChanges.forEach(change -&gt; {</span>
<span class="nc" id="L764">            sb.append(change.toDebugStatement()).append(&quot;, &quot;).append(System.lineSeparator());</span>
<span class="nc" id="L765">        });</span>

<span class="nc" id="L767">        sb.append(&quot;];&quot;).append(System.lineSeparator())</span>
<span class="nc" id="L768">            .append(System.lineSeparator())</span>
<span class="nc" id="L769">            .append(&quot;const newValue = LiveHelper.process(initialValue, initialRevision, changes);&quot;)</span>
<span class="nc" id="L770">            .append(System.lineSeparator())</span>
<span class="nc" id="L771">            .append(&quot;});&quot;);</span>

<span class="nc" id="L773">        this.debugData = sb.toString();</span>
<span class="nc" id="L774">    }</span>

    /**
     * Print debug message
     */
    public void printDebugData() {
<span class="nc" id="L780">        logger.warn(&quot;Debug Data {}&quot;, this.debugData);</span>
<span class="nc" id="L781">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>