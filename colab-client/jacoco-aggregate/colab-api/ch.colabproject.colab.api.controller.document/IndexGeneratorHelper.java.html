<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IndexGeneratorHelper.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-client</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.controller.document</a> &gt; <span class="el_source">IndexGeneratorHelper.java</span></div><h1>IndexGeneratorHelper.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021-2023 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.controller.document;

import ch.colabproject.colab.api.model.WithIndex;
import ch.colabproject.colab.generator.model.exceptions.HttpErrorMessage;
import ch.colabproject.colab.generator.model.exceptions.MessageI18nKey;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;

/**
 * Deal with assigning index in a collection. The index is a field of the object and not the
 * built-in index of a list.
 * &lt;p&gt;
 * The indexes are progressive (from small to big) but the size of the room between two neighboring
 * indexes is not minimal nor has to be regular. In other words two neighboring indexes do not need
 * to be two just-following numbers.
 * &lt;p&gt;
 * The purpose is to be able to easily add an object between others without having to adjust other
 * indexes. In order to do that, we set a room between two neighboring indexes.
 *
 * @author sandra
 * @author maxence
 *
 * @param &lt;T&gt; Type of the items
 */
@Stateless
@LocalBean
public class IndexGeneratorHelper&lt;T extends WithIndex&gt; {

    /**
     * The default value of the smallest index that is suitable
     */
<span class="nc" id="L42">    private final int DEFAULT_MIN_INDEX = 0;</span>

    /**
     * The default value of the biggest index that is suitable
     */
<span class="nc" id="L47">    private final int DEFAULT_MAX_INDEX = Integer.MAX_VALUE;</span>

    /**
     * Default room between two neighboring indexes
     */
<span class="nc" id="L52">    private final int DEFAULT_INDEX_INC = 1000;</span>

    /**
     * Value of the smallest index that is suitable
     */
    private final int minIndex;

    /**
     * Value of the biggest index that is suitable
     */
    private final int maxIndex;

    /**
     * Initial room between two neighboring indexes
     */
    private final int indexIncrement;

    /**
     * Index for the first item in the list
     */
    private final int soloIndex;

    /**
     * Default constructor
     */
<span class="nc" id="L77">    public IndexGeneratorHelper() {</span>
<span class="nc" id="L78">        minIndex = DEFAULT_MIN_INDEX;</span>
<span class="nc" id="L79">        maxIndex = DEFAULT_MAX_INDEX;</span>
<span class="nc" id="L80">        indexIncrement = DEFAULT_INDEX_INC;</span>

<span class="nc" id="L82">        soloIndex = minIndex + indexIncrement;</span>
<span class="nc" id="L83">    }</span>

    /**
     * Constructor with parameters
     *
     * @param minIndex       The value of the smallest index that is suitable
     * @param maxIndex       The value of the biggest index that is suitable
     * @param indexIncrement The initial room between two neighboring indexes
     */
<span class="nc" id="L92">    public IndexGeneratorHelper(int minIndex, int maxIndex, int indexIncrement) {</span>
<span class="nc" id="L93">        this.minIndex = minIndex;</span>
<span class="nc" id="L94">        this.maxIndex = maxIndex;</span>
<span class="nc" id="L95">        this.indexIncrement = indexIncrement;</span>

<span class="nc" id="L97">        soloIndex = minIndex + indexIncrement;</span>
<span class="nc" id="L98">    }</span>

    // *********************************************************************************************
    //
    // *********************************************************************************************

    /**
     * Move (or set) the given item at the beginning of the collection.
     * &lt;p&gt;
     * That means setting an index to the item so that it is the first when sorting by index.
     *
     * @param item       the item waiting for an index to be set
     * @param collection the collection of items
     *
     * @throws HttpErrorMessage if the collection is too big
     */
    public void moveItemToBeginning(T item, Collection&lt;T&gt; collection) {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (collection.isEmpty()) {</span>
<span class="nc" id="L116">            item.setIndex(soloIndex);</span>
        } else {
<span class="nc" id="L118">            List&lt;T&gt; sortedList = sortCollection(collection);</span>

<span class="nc" id="L120">            T baseItem = sortedList.get(0);</span>

<span class="nc" id="L122">            int justTooLow = minIndex - 1;</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (!hasEnoughSpaceBetween(justTooLow, baseItem.getIndex())) {</span>
<span class="nc" id="L125">                reorderIndexes(sortedList);</span>
            }

<span class="nc" id="L128">            int wantedIndex = computeInBetweenIndex(justTooLow, baseItem.getIndex());</span>

<span class="nc" id="L130">            item.setIndex(wantedIndex);</span>
        }
<span class="nc" id="L132">    }</span>

    /**
     * Move the given item one step ahead from where it is now.
     *
     * @param item       the item waiting for a new index
     * @param collection the collection of items
     *
     * @throws HttpErrorMessage if the item is not in the collection
     */
    public void moveOneStepAhead(T item, Collection&lt;T&gt; collection) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (!collection.contains(item)) {</span>
<span class="nc" id="L144">            throw HttpErrorMessage.dataError(MessageI18nKey.DATA_INTEGRITY_FAILURE);</span>
        }

<span class="nc" id="L147">        List&lt;T&gt; sortedList = sortCollection(collection);</span>

<span class="nc" id="L149">        T item1 = getItemBefore(item, sortedList);</span>

<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (item1 == null) {</span>
            // already at the beginning
<span class="nc" id="L153">            return;</span>
        }

<span class="nc" id="L156">        int itemIndex = item.getIndex();</span>
<span class="nc" id="L157">        item.setIndex(item1.getIndex());</span>
<span class="nc" id="L158">        item1.setIndex(itemIndex);</span>
<span class="nc" id="L159">    }</span>

    /**
     * Move (or set) the given item before the baseItem.
     *
     * @param item       the item waiting for a new index
     * @param baseItem   the item of reference
     * @param collection the collection of items
     *
     * @throws HttpErrorMessage if the baseItem is not in the collection or if the collection is too
     *                          big
     */
    public void moveItemBefore(T item, T baseItem, Collection&lt;T&gt; collection) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (!collection.contains(baseItem)) {</span>
<span class="nc" id="L173">            throw HttpErrorMessage.dataError(MessageI18nKey.DATA_INTEGRITY_FAILURE);</span>
        }

<span class="nc" id="L176">        List&lt;T&gt; sortedList = sortCollection(collection);</span>

<span class="nc" id="L178">        T item1 = baseItem;</span>
<span class="nc" id="L179">        T item2 = getItemBefore(baseItem, sortedList);</span>

<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (item2 == null) {</span>
            // set before item1 which is the first item
<span class="nc" id="L183">            moveItemToBeginning(item, collection);</span>

        } else {
            // between two items
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (!hasEnoughSpaceBetween(item1.getIndex(), item2.getIndex())) {</span>
<span class="nc" id="L188">                reorderIndexes(sortedList);</span>
            }

<span class="nc" id="L191">            int wantedIndex = computeInBetweenIndex(item1.getIndex(), item2.getIndex());</span>

<span class="nc" id="L193">            item.setIndex(wantedIndex);</span>
        }
<span class="nc" id="L195">    }</span>

    /**
     * Move an item one step behind from where it is now.
     *
     * @param item       the item waiting for a new index
     * @param collection the collection of items
     *
     * @throws HttpErrorMessage if the item is not in the collection
     */
    public void moveOneStepBehind(T item, Collection&lt;T&gt; collection) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (!collection.contains(item)) {</span>
<span class="nc" id="L207">            throw HttpErrorMessage.dataError(MessageI18nKey.DATA_INTEGRITY_FAILURE);</span>
        }

<span class="nc" id="L210">        List&lt;T&gt; sortedList = sortCollection(collection);</span>

<span class="nc" id="L212">        T item1 = getItemAfter(item, sortedList);</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (item1 == null) {</span>
            // already at the end
<span class="nc" id="L216">            return;</span>
        }

<span class="nc" id="L219">        int itemIndex = item.getIndex();</span>
<span class="nc" id="L220">        item.setIndex(item1.getIndex());</span>
<span class="nc" id="L221">        item1.setIndex(itemIndex);</span>
<span class="nc" id="L222">    }</span>

    /**
     * Move (or set) the given item after the baseItem.
     *
     * @param item       the item waiting for a new index
     * @param baseItem   the item of reference
     * @param collection the collection of items
     *
     * @throws HttpErrorMessage if the baseItem is not in the collection or if the collection is too
     *                          big
     */
    public void moveItemAfter(T item, T baseItem, Collection&lt;T&gt; collection) {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (!collection.contains(baseItem)) {</span>
<span class="nc" id="L236">            throw HttpErrorMessage.dataError(MessageI18nKey.DATA_INTEGRITY_FAILURE);</span>
        }

<span class="nc" id="L239">        List&lt;T&gt; sortedList = sortCollection(collection);</span>

<span class="nc" id="L241">        T item1 = baseItem;</span>
<span class="nc" id="L242">        T item2 = getItemAfter(baseItem, sortedList);</span>

<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (item2 == null) {</span>
            // set after item1 which is the last item
<span class="nc" id="L246">            moveItemToEnd(item, collection);</span>

        } else {
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (!hasEnoughSpaceBetween(item1.getIndex(), item2.getIndex())) {</span>
<span class="nc" id="L250">                reorderIndexes(sortedList);</span>
            }

<span class="nc" id="L253">            int wantedIndex = computeInBetweenIndex(item1.getIndex(), item2.getIndex());</span>

<span class="nc" id="L255">            item.setIndex(wantedIndex);</span>
        }
<span class="nc" id="L257">    }</span>

    /**
     * Move (or set) the given item at the end of the collection.
     * &lt;p&gt;
     * That means setting an index to the item so that it is the last when sorting by index.
     *
     * @param item       the item waiting for an index to be set
     * @param collection the collection of items
     *
     * @throws HttpErrorMessage if the collection is too big
     */
    public void moveItemToEnd(T item, Collection&lt;T&gt; collection) {
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (collection.isEmpty()) {</span>
<span class="nc" id="L271">            item.setIndex(soloIndex);</span>
        } else {
<span class="nc" id="L273">            List&lt;T&gt; sortedList = sortCollection(collection);</span>

<span class="nc" id="L275">            T baseItem = sortedList.get(sortedList.size() - 1);</span>

<span class="nc" id="L277">            int justTooBigIndex = maxIndex + 1;</span>

<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (!hasEnoughSpaceBetween(baseItem.getIndex(), justTooBigIndex)) {</span>
<span class="nc" id="L280">                reorderIndexes(sortedList);</span>
            }

            int wantedIndex;
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if ((justTooBigIndex - baseItem.getIndex()) &gt; indexIncrement) {</span>
<span class="nc" id="L285">                wantedIndex = baseItem.getIndex() + indexIncrement;</span>
            } else {
<span class="nc" id="L287">                wantedIndex = computeInBetweenIndex(baseItem.getIndex(), justTooBigIndex);</span>
            }

<span class="nc" id="L290">            item.setIndex(wantedIndex);</span>
        }
<span class="nc" id="L292">    }</span>

    // *********************************************************************************************
    //
    // *********************************************************************************************

    /**
     * Reorder the list so that each neighboring items have items separated by
     * {@link #indexIncrement}.
     * &lt;p&gt;
     * The first item also has a room of {@link #indexIncrement} before it.
     *
     * @param sortedCollection The sorted collection to index again
     *
     * @throws HttpErrorMessage if the collection is too big to be reorder
     */
    private void reorderIndexes(List&lt;T&gt; sortedCollection) {
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (!canBeReordered(sortedCollection)) {</span>
<span class="nc" id="L310">            throw HttpErrorMessage.dataError(MessageI18nKey.DATA_INTEGRITY_FAILURE);</span>
        }

<span class="nc" id="L313">        int index = minIndex + indexIncrement;</span>

<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (WithIndex obj : sortedCollection) {</span>
<span class="nc" id="L316">            obj.setIndex(index);</span>
<span class="nc" id="L317">            index += indexIncrement;</span>
<span class="nc" id="L318">        }</span>
<span class="nc" id="L319">    }</span>

    /**
     * Compute if the collection size fits into items indexes separated by {@link #indexIncrement}
     * between {@link #minIndex} and {@link #maxIndex}
     *
     * @param collection
     *
     * @return True if the collection size fits into
     */
    private boolean canBeReordered(Collection&lt;T&gt; collection) {
<span class="nc" id="L330">        return Math.floor(((float) (maxIndex - minIndex)) / indexIncrement) - 1 &gt;= collection</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            .size();</span>
    }

    // *********************************************************************************************
    //
    // *********************************************************************************************

    /**
     * Sort the collection by the items index field.
     *
     * @param collection the collection of items to sort
     *
     * @return a list of sorted items by index
     */
    private List&lt;T&gt; sortCollection(Collection&lt;T&gt; collection) {
<span class="nc" id="L346">        List&lt;T&gt; sortedList = new ArrayList&lt;&gt;(collection);</span>

<span class="nc" id="L348">        sortedList.sort(Comparator.comparingInt(obj -&gt; obj.getIndex()));</span>

        // TODO sandra ask Maxence if the old way was more suitable
//      sortedList.sort((a, b) -&gt; {
//      if (a != null) {
//          if (b != null) {
//              return Math.max(a.getIndex(), b.getIndex());
//          } else {
//              // a is not null, b is null
//              return -1;
//          }
//      } else if (b != null) {
//          // a is null, not b
//          return 1;
//      }
//      //both are null
//      return 0;

<span class="nc" id="L366">        return sortedList;</span>
    }

    // *********************************************************************************************
    //
    // *********************************************************************************************

    /**
     * Determine if there is enough space between two indexes so that we can insert something new.
     *
     * @param indexA an index
     * @param indexB another index
     *
     * @return True if there is at least 1 room left between the two indexes
     */
    private boolean hasEnoughSpaceBetween(int indexA, int indexB) {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        return Math.abs(indexB - indexA) &gt; 1;</span>
    }

    /**
     * Determine the new index which will take place between the two given indexes.
     *
     * @param indexA an index
     * @param indexB another index
     *
     * @return An index that fits between the two given indexes
     */
    private int computeInBetweenIndex(int indexA, int indexB) {
<span class="nc" id="L394">        int baseIndex = indexA;</span>

<span class="nc" id="L396">        int delta = indexB - baseIndex;</span>
<span class="nc" id="L397">        int increment = (int) Math.floor(delta / 2.0);</span>

<span class="nc" id="L399">        return baseIndex + increment;</span>
    }

    /**
     * Fetch the item which is just before the given baseItem in the sortedList.
     *
     * @param baseItem   the reference item
     * @param sortedList the sorted list of items
     *
     * @return the item just before baseItem
     *
     * @throws HttpErrorMessage if the sorted list does not contain the baseItem
     */
    private T getItemBefore(T baseItem, List&lt;T&gt; sortedList) {
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (!sortedList.contains(baseItem)) {</span>
<span class="nc" id="L414">            throw HttpErrorMessage.dataError(MessageI18nKey.DATA_INTEGRITY_FAILURE);</span>
        }

<span class="nc" id="L417">        int baseIndexInList = sortedList.indexOf(baseItem);</span>

<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (baseIndexInList &gt; 0) {</span>
<span class="nc" id="L420">            return sortedList.get(baseIndexInList - 1);</span>
        } else {
            // nothing before baseItem
<span class="nc" id="L423">            return null;</span>
        }
    }

    /**
     * Fetch the item which is just after the given baseItem in the sortedList.
     *
     * @param baseItem   the reference item
     * @param sortedList the sorted list of items
     *
     * @return the item just after baseItem
     *
     * @throws HttpErrorMessage if the sorted list does not contain the baseItem
     */
    private T getItemAfter(T baseItem, List&lt;T&gt; sortedList) {
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (!sortedList.contains(baseItem)) {</span>
<span class="nc" id="L439">            throw HttpErrorMessage.dataError(MessageI18nKey.DATA_INTEGRITY_FAILURE);</span>
        }

<span class="nc" id="L442">        int baseIndexInList = sortedList.indexOf(baseItem);</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (baseIndexInList &lt; sortedList.size() - 1) {</span>
<span class="nc" id="L445">            return sortedList.get(baseIndexInList + 1);</span>
        } else {
            // nothing after baseItem
<span class="nc" id="L448">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>