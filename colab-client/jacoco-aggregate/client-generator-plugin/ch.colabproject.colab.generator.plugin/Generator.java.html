<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Generator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-client</a> &gt; <a href="../index.html" class="el_bundle">client-generator-plugin</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.generator.plugin</a> &gt; <span class="el_source">Generator.java</span></div><h1>Generator.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021-2023 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.generator.plugin;

import ch.colabproject.colab.generator.model.interfaces.WithId;
import ch.colabproject.colab.generator.model.interfaces.WithJsonDiscriminator;
import ch.colabproject.colab.generator.model.tools.ClassDoc;
import ch.colabproject.colab.generator.model.tools.JavaDocExtractor;
import ch.colabproject.colab.generator.model.tools.JsonbProvider;
import ch.colabproject.colab.generator.plugin.rest.RestEndpoint;
import java.io.BufferedWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;
import javax.json.bind.Jsonb;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.Path;
import org.apache.maven.plugin.MojoFailureException;
import org.reflections.Reflections;

/**
 *
 * @author maxence
 */
public class Generator {

    /**
     * Reflections one-stop-shop object.
     */
    private final Reflections reflections;

    /**
     * All rest controller found.
     */
    private Set&lt;RestEndpoint&gt; restEndpoints;

    /**
     * Client will be generated in this package
     */
    private final String packageName;

    /**
     * Generated client name
     */
    private final String clientName;

    /**
     * Javadoc as extracted by the annotation processor
     */
    private final Map&lt;String, ClassDoc&gt; javadoc;

    /**
     * Main REST application path
     */
<span class="nc" id="L68">    private String applicationPath = null;</span>

    /**
     * Initialize the client generator.
     *
     * @param restPackages packages to analyze
     * @param packageName  package in which generate the client
     * @param clientName   client class name
     */
    public Generator(String[] restPackages,
        String packageName, String clientName
<span class="nc" id="L79">    ) {</span>
<span class="nc" id="L80">        this.packageName = packageName;</span>
<span class="nc" id="L81">        this.clientName = clientName;</span>

<span class="nc" id="L83">        List&lt;Object&gt; pkgs = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L84">        pkgs.add(&quot;ch.colabproject.colab.generator.model&quot;);</span>
<span class="nc" id="L85">        pkgs.addAll(Arrays.asList(restPackages));</span>

<span class="nc" id="L87">        this.reflections = new Reflections(pkgs.toArray());</span>
<span class="nc" id="L88">        this.javadoc = JavaDocExtractor.loadJavaDocFromJson();</span>
<span class="nc" id="L89">    }</span>

    /**
     *
     * Initialize the client generator.
     *
     * @param pkgs packages to analyze
     */
    public Generator(String[] pkgs) {
<span class="nc" id="L98">        this(pkgs, null, null);</span>
<span class="nc" id="L99">    }</span>

    /**
     * get JSON-B to use.
     *
     * @return jsbonb mapper
     */
    public Jsonb getJsonBMapper() {
<span class="nc" id="L107">        return JsonbProvider.getJsonb();</span>
    }

    /**
     * Process all classes annotated with {@link Path}. Generate a {@link RestEndpoint} instance
     * for each class and store them in {@link #restEndpoints}
     */
    public void processPackages() {
<span class="nc" id="L115">        Set&lt;Class&lt;?&gt;&gt; appConfig = reflections.getTypesAnnotatedWith(ApplicationPath.class);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (!appConfig.isEmpty()) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (appConfig.size() &gt; 1) {</span>
<span class="nc" id="L118">                Logger.warn(&quot;Several ApplicationPath found&quot;);</span>
            }
<span class="nc" id="L120">            Class&lt;?&gt; applicationConfig = appConfig.iterator().next();</span>
<span class="nc" id="L121">            ApplicationPath annotation = applicationConfig.getAnnotation(ApplicationPath.class);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (annotation != null) {</span>
<span class="nc" id="L123">                this.applicationPath = annotation.value();</span>
            }
        }

<span class="nc" id="L127">        Set&lt;Class&lt;?&gt;&gt; restClasses = reflections.getTypesAnnotatedWith(Path.class);</span>

<span class="nc" id="L129">        this.restEndpoints = restClasses.stream()</span>
<span class="nc" id="L130">            .map(klass -&gt; RestEndpoint.build(klass, applicationPath))</span>
<span class="nc" id="L131">            .collect(Collectors.toSet());</span>
        /* .map(p -&gt; p.generateJavaClient()) .innerClasses(Collectors.toList());
         */
<span class="nc" id="L134">    }</span>

    /**
     * One all classes have been processed with {@link #processPackages() }, this method will create
     * subdirectories that match the &lt;code&gt;packageName&lt;/code&gt;.Then the client will be generated in
     * the &lt;code&gt;clientName&lt;/code&gt;.java file.
     *
     * @param targetDir target directory
     * @param dryRun    if true, do not generate files but print output to console
     *
     * @throws org.apache.maven.plugin.MojoFailureException if generation fails
     */
    public void generateJavaClient(String targetDir, boolean dryRun) throws MojoFailureException {
<span class="nc" id="L147">        Map&lt;String, String&gt; imports = new HashMap&lt;&gt;();</span>
<span class="nc" id="L148">        imports.put(&quot;RestClient&quot;, &quot;ch.colabproject.colab.generator.plugin.rest.RestClient&quot;);</span>
<span class="nc" id="L149">        imports.put(&quot;Jsonb&quot;, &quot;javax.json.bind.Jsonb&quot;);</span>
<span class="nc" id="L150">        imports.put(&quot;GenericType&quot;, &quot;javax.ws.rs.core.GenericType&quot;);</span>
<span class="nc" id="L151">        imports.put(&quot;PathPattern&quot;, &quot;org.glassfish.jersey.uri.PathPattern&quot;);</span>
<span class="nc" id="L152">        imports.put(&quot;UriTemplate&quot;, &quot;org.glassfish.jersey.uri.UriTemplate&quot;);</span>
<span class="nc" id="L153">        imports.put(&quot;void&quot;, null); // null means no import statement</span>

<span class="nc" id="L155">        String innerClasses = this.restEndpoints.stream().map(controller -&gt; {</span>
<span class="nc" id="L156">        String javaCode = controller.generateJavaClient(</span>
                imports,
                clientName,
                javadoc,
                reflections
            );
<span class="nc" id="L162">            return javaCode;</span>
<span class="nc" id="L163">        }).collect(Collectors.joining(System.lineSeparator()));</span>

<span class="nc" id="L165">        StringBuilder sb = new StringBuilder();</span>

<span class="nc" id="L167">        sb.append(&quot;package &quot;).append(packageName).append(&quot;;\n\n&quot;)</span>
<span class="nc" id="L168">            .append(</span>
<span class="nc" id="L169">                imports.values().stream()</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                    .filter(pkg -&gt; pkg != null)</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                    .filter(pkg -&gt; !pkg.startsWith(&quot;java.lang&quot;)) // do not import java.lang</span>
<span class="nc" id="L172">                    .sorted()</span>
<span class="nc" id="L173">                    .map(pkg -&gt; &quot;import &quot; + pkg + &quot;;&quot;)</span>
<span class="nc" id="L174">                    .collect(Collectors.joining(System.lineSeparator()))</span>
            )
<span class="nc" id="L176">            .append(&quot;\n&quot;</span>
                + &quot;/**\n&quot;
                + &quot; * The &quot;)
<span class="nc" id="L179">            .append(clientName)</span>
<span class="nc" id="L180">            .append(&quot; REST client&quot;</span>
                + &quot; */\n&quot;
                + &quot;@SuppressWarnings(\&quot;PMD.FieldDeclarationsShouldBeAtStartOfClass\&quot;)\n&quot;
                + &quot;public class &quot;)
<span class="nc" id="L184">            .append(clientName)</span>
<span class="nc" id="L185">            .append(&quot; extends RestClient {&quot;</span>
                + &quot;\n&quot;
                + &quot;\n&quot;
                + &quot;    /**\n&quot;
                + &quot;     * Get a REST client\n&quot;
                + &quot;     *\n&quot;
                + &quot;     * @param baseUri        base URI\n&quot;
                + &quot;     * @param cookieName     session cookie name\n&quot;
                + &quot;     * @param jsonb          jsonb\n&quot;
                + &quot;     * @param clientFeatures addition http client feature\n&quot;
                + &quot;     */\n&quot;
                + &quot;    public &quot;)
<span class="nc" id="L197">            .append(clientName)</span>
<span class="nc" id="L198">            .append(&quot;(String baseUri, String cookieName, Jsonb jsonb, Object... clientFeatures) {\n&quot;</span>
                + &quot;        super(baseUri, cookieName, jsonb, clientFeatures);\n&quot;
                + &quot;    }&quot;)
<span class="nc" id="L201">            .append(innerClasses)</span>
<span class="nc" id="L202">            .append(&quot;}&quot;);</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (dryRun) {</span>
<span class="nc" id="L205">            Logger.debug(sb.toString());</span>
        } else {
<span class="nc" id="L207">            String packagePath = targetDir + &quot;/&quot; + packageName.replaceAll(&quot;\\.&quot;, &quot;/&quot;);</span>
<span class="nc" id="L208">            writeFile(sb.toString(), packagePath, clientName + &quot;.java&quot;);</span>
        }
<span class="nc" id="L210">    }</span>

    /**
     * Get rest service description
     *
     * @return all rest resource
     */
    public Set&lt;RestEndpoint&gt; getRestEndpoints() {
<span class="nc" id="L218">        return restEndpoints;</span>
    }

    /**
     * Generate typescript client in targetDir
     *
     * @param targetDir generate TS module in this directory
     * @param dryRun    if true, do not generate any file but print output to console
     *
     * @throws org.apache.maven.plugin.MojoFailureException if generation fails
     */
    public void generateTypescriptClient(String targetDir, boolean dryRun)
        throws MojoFailureException {
<span class="nc" id="L231">        Map&lt;String, Type&gt; extraTypes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L232">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L233">        sb.append(this.getTsClientTemplate());</span>
<span class="nc" id="L234">        extraTypes.put(&quot;WithJsonDiscriminator&quot;, WithJsonDiscriminator.class);</span>
<span class="nc" id="L235">        extraTypes.put(&quot;WithId&quot;, WithId.class);</span>

<span class="nc" id="L237">        String modules = this.restEndpoints.stream().map(controller</span>
<span class="nc" id="L238">            -&gt; controller.generateTypescriptClient(extraTypes, this.javadoc, reflections)</span>
<span class="nc" id="L239">        ).collect(Collectors.joining(System.lineSeparator()));</span>

        // TS interface name =&gt; list of @class values
<span class="nc" id="L242">        Map&lt;String, List&lt;String&gt;&gt; inheritance = new HashMap&lt;&gt;();</span>

<span class="nc" id="L244">        List&lt;Entry&lt;String, Type&gt;&gt; queue = new ArrayList&lt;&gt;(extraTypes.entrySet());</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        while (!queue.isEmpty()) {</span>
<span class="nc" id="L246">            Map&lt;String, Type&gt; snowballedTypes = new HashMap&lt;&gt;();</span>

<span class="nc" id="L248">            Entry&lt;String, Type&gt; entry = queue.remove(0);</span>

<span class="nc" id="L250">            String tsInterface = TypeScriptHelper.generateInterface(</span>
<span class="nc" id="L251">                entry.getValue(),</span>
                snowballedTypes,
                inheritance,
                reflections,
                javadoc
            );
<span class="nc" id="L257">            sb.append(tsInterface);</span>

<span class="nc" id="L259">            snowballedTypes.forEach((name, type) -&gt; {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (!extraTypes.containsKey(name)) {</span>
<span class="nc" id="L261">                    extraTypes.put(name, type);</span>
<span class="nc" id="L262">                    queue.add(0, new SimpleEntry&lt;&gt;(name, type));</span>
                }
<span class="nc" id="L264">            });</span>
<span class="nc" id="L265">        }</span>

<span class="nc" id="L267">        sb.append(&quot;/**\n&quot;</span>
            + &quot; * Some orthopedic tools\n&quot;
            + &quot; */\n\n&quot;
            + &quot;export interface TypeMap {\n  &quot;)
<span class="nc" id="L271">            .append(</span>
<span class="nc" id="L272">                inheritance.keySet().stream().map((key)</span>
<span class="nc" id="L273">                    -&gt; key + &quot;: &quot; + key + &quot;;&quot;)</span>
<span class="nc" id="L274">                    .collect(Collectors.joining(&quot;\n  &quot;))</span>
            )
<span class="nc" id="L276">            .append(&quot;\n}\n\n&quot;)</span>
<span class="nc" id="L277">            .append(&quot;const inheritance : {[key: string]: string[]} = {\n&quot;)</span>
<span class="nc" id="L278">            .append(</span>
<span class="nc" id="L279">                inheritance.entrySet().stream().map((entry)</span>
<span class="nc" id="L280">                    -&gt; entry.getKey() + &quot;: [&quot; + entry.getValue().stream()</span>
<span class="nc" id="L281">                .map(v -&gt; &quot;'&quot; + v + &quot;'&quot;)</span>
<span class="nc" id="L282">                .collect(Collectors.joining(&quot;, &quot;)) + &quot;]&quot;</span>
<span class="nc" id="L283">                ).collect(Collectors.joining(&quot;,\n  &quot;)))</span>
<span class="nc" id="L284">            .append(&quot;\n}\n\n&quot;)</span>
<span class="nc" id="L285">            .append(&quot;export const entityIs = &lt;T extends keyof TypeMap&gt;(entity: unknown, klass: T)\n&quot;</span>
                + &quot;    : entity is TypeMap[T] =&gt; {\n&quot;
                + &quot;\n&quot;
                + &quot;    if (typeof entity === 'object' &amp;&amp; entity != null) {\n&quot;
                + &quot;        if (\&quot;@class\&quot; in entity) {\n&quot;
                + &quot;            const dis = entity[\&quot;@class\&quot;];\n&quot;
                + &quot;            if (typeof dis === 'string') {\n&quot;
                + &quot;                return inheritance[klass].includes(dis);\n&quot;
                + &quot;            }\n&quot;
                + &quot;        }\n&quot;
                + &quot;    }\n&quot;
                + &quot;    return false;\n&quot;
                + &quot;}&quot;)
<span class="nc" id="L298">            .append(&quot;\n\n\n/**\n&quot;</span>
<span class="nc" id="L299">                + &quot;* The &quot;).append(clientName).append(&quot; REST client\n&quot;</span>
            + &quot; */\n&quot;
<span class="nc" id="L301">            + &quot;export const &quot;).append(clientName)</span>
<span class="nc" id="L302">            .append(&quot; = function (baseUrl: string, defaultErrorHandler: (error: unknown) =&gt; void) {&quot;)</span>
<span class="nc" id="L303">            .append(&quot;\n    return {&quot;)</span>
<span class="nc" id="L304">            .append(modules)</span>
<span class="nc" id="L305">            .append(&quot;    }\n&quot;)</span>
<span class="nc" id="L306">            .append(&quot;}&quot;);</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (dryRun) {</span>
<span class="nc" id="L309">            Logger.debug(sb.toString());</span>
        } else {
<span class="nc" id="L311">            String srcPath = targetDir + &quot;/src&quot;;</span>
<span class="nc" id="L312">            writeFile(sb.toString(), srcPath, clientName + &quot;.ts&quot;);</span>

<span class="nc" id="L314">            writeFile(&quot;export * from './dist/&quot; + clientName + &quot;';&quot;, targetDir, &quot;index.ts&quot;);</span>
<span class="nc" id="L315">            writeFile(generatePackageDotJson(), targetDir, &quot;package.json&quot;);</span>
<span class="nc" id="L316">            writeFile(generateTsconfigDotJson(), targetDir, &quot;tsconfig.json&quot;);</span>
        }
<span class="nc" id="L318">    }</span>

    /**
     * Write file to disk.
     *
     * @param content   file content
     * @param directory directory, will be created if missing
     * @param filename  filename
     */
    private void writeFile(String content, String directory, String filename)
        throws MojoFailureException {
        try {
<span class="nc" id="L330">            Files.createDirectories(java.nio.file.Path.of(directory));</span>

<span class="nc" id="L332">            try (BufferedWriter writer = Files.newBufferedWriter(</span>
<span class="nc" id="L333">                java.nio.file.Path.of(directory, filename))) {</span>
<span class="nc" id="L334">                writer.write(content);</span>
<span class="nc" id="L335">            } catch (IOException ex) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (Logger.isInit()) {</span>
<span class="nc" id="L337">                    throw new MojoFailureException(&quot;Failed to write '&quot;</span>
                        + filename + &quot;' in '&quot; + directory + &quot;'&quot;, ex);
                }
<span class="nc" id="L340">            }</span>

<span class="nc" id="L342">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (Logger.isInit()) {</span>
<span class="nc" id="L344">                throw new MojoFailureException(&quot;Failed to create package directory &quot;</span>
                    + directory, ex);
            }
<span class="nc" id="L347">        }</span>
<span class="nc" id="L348">    }</span>

    /**
     * Convert Java className-like to dash-separated-lower-case version.
     *
     * @param name eg. MyAwesomeRestClient
     *
     * @return eg. my-awesome-rest-client
     */
    private String generateModuleName(String name) {
<span class="nc" id="L358">        return name</span>
<span class="nc" id="L359">            .trim()</span>
            // prefix all uppercase char preceded by something with an dash
<span class="nc" id="L361">            .replaceAll(&quot;(?&lt;!^)[A-Z](?!$)&quot;, &quot;-$0&quot;)</span>
<span class="nc" id="L362">            .toLowerCase();</span>
    }

    /**
     * get TS client tempalte
     *
     * @return intial content of the TS client
     */
    private String getTsClientTemplate() {
<span class="nc" id="L371">        String tsConfig = FileHelper.readFile(&quot;templates/client.ts&quot;);</span>
<span class="nc" id="L372">        return tsConfig.replaceAll(</span>
            &quot;\\{\\{MODULE_NAME\\}\\}&quot;,
<span class="nc" id="L374">            generateModuleName(clientName)</span>
        );
    }

    /**
     * generate package.json
     *
     * @return content of package.json
     */
    private String generatePackageDotJson() {
<span class="nc" id="L384">        String tsConfig = FileHelper.readFile(&quot;templates/package.json&quot;);</span>
<span class="nc" id="L385">        return tsConfig.replaceAll(</span>
            &quot;\\{\\{MODULE_NAME\\}\\}&quot;,
<span class="nc" id="L387">            generateModuleName(clientName)</span>
        );
    }

    /**
     * generate tsconfig.json
     *
     * @return content of package.json
     */
    private String generateTsconfigDotJson() {
<span class="nc" id="L397">        String tsConfig = FileHelper.readFile(&quot;templates/tsconfig.json&quot;);</span>
<span class="nc" id="L398">        return tsConfig.replaceAll(&quot;\\{\\{CLIENT_NAME\\}\\}&quot;, this.clientName);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>