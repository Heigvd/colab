<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LiveUpdates.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-tests</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.microchanges.live</a> &gt; <span class="el_source">LiveUpdates.java</span></div><h1>LiveUpdates.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.microchanges.live;

import ch.colabproject.colab.api.microchanges.model.Change;
import ch.colabproject.colab.api.microchanges.model.MicroChange;
import ch.colabproject.colab.api.microchanges.model.MicroChange.Type;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Set of pending changes.
 *
 * @author maxence
 */
<span class="fc" id="L31">public class LiveUpdates implements Serializable {</span>

    private static final long serialVersionUID = 1L;

    /** Logger */
<span class="fc" id="L36">    private static final Logger logger = LoggerFactory.getLogger(LiveUpdates.class);</span>

    /**
     * JsonDiscriminator to fetch the class this change targets
     */
    private String targetClass;

    /**
     * Id of the object this change targets
     */
    private Long targetId;

    /**
     * initial revision of content
     */
    private String revision;

    /**
     * root content
     */
    private String content;

    /**
     * List of pending changes
     */
<span class="fc" id="L61">    private List&lt;Change&gt; pendingChanges = new ArrayList&lt;&gt;();</span>

    /**
     * Get the JSON discriminator
     *
     * @return JSON discriminator
     */
    public String getTargetClass() {
<span class="nc" id="L69">        return targetClass;</span>
    }

    /**
     * Set the JSON discriminator
     *
     * @param targetClass new discriminator
     */
    public void setTargetClass(String targetClass) {
<span class="fc" id="L78">        this.targetClass = targetClass;</span>
<span class="fc" id="L79">    }</span>

    /**
     * The object id.
     *
     * @return the id of the object
     */
    public Long getTargetId() {
<span class="nc" id="L87">        return targetId;</span>
    }

    /**
     * set object id
     *
     * @param targetId object id
     */
    public void setTargetId(Long targetId) {
<span class="fc" id="L96">        this.targetId = targetId;</span>
<span class="fc" id="L97">    }</span>

    /**
     * Get the revision
     *
     * @return the revision
     */
    public String getRevision() {
<span class="nc" id="L105">        return revision;</span>
    }

    /**
     * Set the revision
     *
     * @param revision the revision
     */
    public void setRevision(String revision) {
<span class="fc" id="L114">        this.revision = revision;</span>
<span class="fc" id="L115">    }</span>

    /**
     * Get initial &quot;root&quot; content
     *
     * @return the root content
     */
    public String getContent() {
<span class="nc" id="L123">        return content;</span>
    }

    /**
     * Set initial content
     *
     * @param content the content
     */
    public void setContent(String content) {
<span class="fc" id="L132">        this.content = content;</span>
<span class="fc" id="L133">    }</span>

    /**
     * Get the list of pending changes
     *
     * @return changes
     */
    public List&lt;Change&gt; getPendingChanges() {
<span class="fc" id="L141">        return pendingChanges;</span>
    }

    /**
     * set the list of pending changes
     *
     * @param pendingChanges changes
     */
    public void setPendingChanges(List&lt;Change&gt; pendingChanges) {
<span class="fc" id="L150">        this.pendingChanges = pendingChanges;</span>
<span class="fc" id="L151">    }</span>

    /**
     * Get change by revision
     *
     * @param changes  all changes
     * @param revision the revision tag
     *
     * @return the change which the given revision or null if such a change does not exist
     */
    public Change getByRevision(List&lt;Change&gt; changes, String revision) {
<span class="fc" id="L162">        Optional&lt;Change&gt; findAny = changes.stream()</span>
<span class="fc" id="L163">            .filter(ch -&gt; ch.getRevision().equals(revision))</span>
<span class="fc" id="L164">            .findAny();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        return findAny.isPresent() ? findAny.get() : null;</span>
    }

    /**
     * Get changes which are direct children of given parent
     *
     * @param changes all changes
     * @param basedOn parent id
     *
     * @return all changes which are based on the given parentId
     */
    public List&lt;Change&gt; getByParent(List&lt;Change&gt; changes, String basedOn) {
<span class="fc" id="L177">        List&lt;Change&gt; collect = changes.stream()</span>
<span class="fc" id="L178">            .filter(ch -&gt; ch.getBasedOn().contains(basedOn))</span>
<span class="fc" id="L179">            .collect(Collectors.toList());</span>
<span class="fc" id="L180">        return new ArrayList&lt;&gt;(collect);</span>
    }

    /**
     * Get changes which are direct children of the given parent, authored by the same live-session.
     * This method is used to detect if a live session has diverged.
     *
     * @param changes list of changes
     * @param parent  parent
     *
     * @return children of parent if they are authored by the same person
     */
    public List&lt;Change&gt; getByParentAndSession(List&lt;Change&gt; changes, Change parent) {
<span class="nc" id="L193">        logger.trace(&quot;Get Children By Parent And Session&quot;);</span>

<span class="nc" id="L195">        List&lt;Change&gt; collect = changes.stream()</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            .filter(ch -&gt; ch.getBasedOn().contains(parent.getRevision())</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            &amp;&amp; ch.getLiveSession().equals(parent.getLiveSession()))</span>
<span class="nc" id="L198">            .collect(Collectors.toList());</span>
<span class="nc" id="L199">        return new ArrayList&lt;&gt;(collect);</span>
    }

    /**
     * Include new offset within the map.
     *
     * @param offsets offsets mapped by indexes
     * @param index   new offset index
     * @param value   new offset value
     */
    private void modifyOffset(Map&lt;Integer, Integer&gt; offsets, Integer index, Integer value) {
<span class="fc" id="L210">        Integer currentOffset = offsets.get(index);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (currentOffset == null) {</span>
<span class="fc" id="L212">            currentOffset = 0;</span>
        }
<span class="fc" id="L214">        currentOffset += value;</span>
<span class="fc" id="L215">        logger.trace(&quot;  modOffset.start &quot; + offsets);</span>

<span class="fc" id="L217">        offsets.put(index, currentOffset);</span>

<span class="fc" id="L219">        logger.trace(&quot;  modOffset.second &quot; + offsets);</span>

<span class="fc" id="L221">        Map&lt;Integer, Integer&gt; modified = new HashMap&lt;&gt;();</span>

        // shift offsets after current index
<span class="fc" id="L224">        offsets.entrySet().forEach(entry -&gt; {</span>
<span class="fc" id="L225">            Integer key = entry.getKey();</span>
<span class="pc bpc" id="L226" title="3 of 4 branches missed.">            if (key &gt; index &amp;&amp; key &lt; index + value) {</span>
<span class="nc" id="L227">                logger.trace(&quot;CONFLIT&quot;);</span>
            }
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">            if (key &gt; index) {</span>
                // move offset to new index
<span class="nc" id="L231">                Integer v = entry.getValue();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                if (v != null) {</span>
<span class="nc" id="L233">                    int newKey = key + value;</span>
<span class="nc" id="L234">                    int newValue = v;</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                    if (offsets.containsKey(newKey)) {</span>
<span class="nc" id="L236">                        newValue = offsets.get(newKey) + newValue;</span>
                    }
<span class="nc" id="L238">                    modified.put(key, 0);</span>
<span class="nc" id="L239">                    modified.put(newKey, newValue);</span>
                }
            }
<span class="fc" id="L242">        });</span>

<span class="fc" id="L244">        logger.trace(&quot;  modOffset.third &quot; + modified);</span>

        // merge shifted offsets
<span class="fc" id="L247">        modified.entrySet().forEach(entry -&gt; {</span>
<span class="nc" id="L248">            Integer key = entry.getKey();</span>
<span class="nc" id="L249">            int current = entry.getValue();</span>
<span class="nc" id="L250">            offsets.put(key, current);</span>
<span class="nc" id="L251">        });</span>

<span class="fc" id="L253">        logger.trace(&quot; mod Offsets.done &quot; + offsets);</span>
<span class="fc" id="L254">    }</span>

    /**
     * Apply microchange to the buffer
     *
     * @param buffer the buffet
     * @param mu     the patch
     */
    private void applyChange(StringBuilder buffer, MicroChange mu) {
<span class="fc" id="L263">        logger.trace(&quot;Apply {} to {}&quot;, mu, buffer);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (mu.getT() == MicroChange.Type.D) {</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (mu.getO() &lt; buffer.length()) {</span>
<span class="fc" id="L266">                buffer.length();</span>
<span class="fc" id="L267">                buffer.delete(mu.getO(), mu.getO() + mu.getL());</span>
            } else {
<span class="nc" id="L269">                logger.trace(&quot;Skip micro change&quot;);</span>
            }
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">        } else if (mu.getT() == MicroChange.Type.I) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (mu.getO() &gt;= buffer.length()) {</span>
<span class="fc" id="L273">                buffer.append(mu.getV());</span>
            } else {
<span class="fc" id="L275">                buffer.insert(mu.getO(), mu.getV());</span>
            }
        }
<span class="fc" id="L278">    }</span>

    /**
     * Compute offset the set of microchanges will generate.
     * &lt;li&gt;2:20 means 20 characters are added at index 2
     * &lt;li&gt;5:-10 means 10 characters are removed from index 5
     *
     * @param change set of microchanges
     *
     * @return offset mapped by index
     */
    private Map&lt;Integer, Integer&gt; computeOffset(Change change) {
<span class="fc" id="L290">        Map&lt;Integer, Integer&gt; offsets = new HashMap&lt;&gt;();</span>

<span class="fc" id="L292">        List&lt;MicroChange&gt; muChanges = change.getMicrochanges();</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = muChanges.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L294">            MicroChange mu = muChanges.get(i);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (mu.getT() == MicroChange.Type.D) {</span>
<span class="fc" id="L296">                modifyOffset(offsets, mu.getO() + mu.getL(), -mu.getL());</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            } else if (mu.getT() == MicroChange.Type.I) {</span>
<span class="fc" id="L298">                modifyOffset(offsets, mu.getO(), mu.getV().length());</span>
            }
        }

<span class="fc" id="L302">        return offsets;</span>
    }

    /**
     * Modify microchange to reflect given offsets
     *
     * @param change  changes to update
     * @param offsets offsets, mapped by indexes
     * @param forward shif if true, unshift otherwise
     *
     * @return true if operation was successful, false if there ws some conflict
     */
    private boolean shift(Change change, Map&lt;Integer, Integer&gt; offsets, boolean forward) {
<span class="fc" id="L315">        boolean conflictFree = true;</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (forward == false) {</span>
<span class="nc" id="L317">            logger.warn(&quot;TODO: implement backward shift&quot;);</span>
        }
        //int way = forward ? 1 : -1; // TODO

<span class="fc" id="L321">        logger.trace(&quot;Shift offsets: {}&quot;, change);</span>
<span class="fc" id="L322">        List&lt;MicroChange&gt; microchanges = change.getMicrochanges();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (int i = 0; i &lt; microchanges.size(); i++) {</span>
<span class="fc" id="L324">            MicroChange mu = microchanges.get(i);</span>

<span class="fc bfc" id="L326" title="All 2 branches covered.">            for (Map.Entry&lt;Integer, Integer&gt; entry : offsets.entrySet()) {</span>
<span class="fc" id="L327">                Integer offsetValue = entry.getValue();</span>
<span class="fc" id="L328">                Integer offsetIndex = entry.getKey();</span>

<span class="fc" id="L330">                int muStart = mu.getO();</span>

<span class="fc bfc" id="L332" title="All 4 branches covered.">                if (offsetValue &gt; 0 &amp;&amp; mu.getT().equals(Type.I)) {</span>
                    // both are insetion
<span class="fc bfc" id="L334" title="All 2 branches covered.">                    if (mu.getO() &gt;= offsetIndex) {</span>
                        // changes is after the first insertion =&gt; shift it
<span class="fc" id="L336">                        mu.setO(mu.getO() + offsetValue);</span>
                    }
<span class="fc bfc" id="L338" title="All 4 branches covered.">                } else if (offsetValue &lt; 0 &amp;&amp; mu.getT().equals(Type.D)) {</span>
                    // both are deletion
<span class="fc" id="L340">                    int deleteFromIndex = offsetIndex + offsetValue;</span>
<span class="fc" id="L341">                    int deleteToIndex = offsetIndex;</span>
<span class="fc" id="L342">                    int muEnd = muStart + mu.getL();</span>

                    // nothing to do if mu is complely before offset
<span class="fc bfc" id="L345" title="All 2 branches covered.">                    if (muEnd &gt;= deleteFromIndex) {</span>
                        // mu is completely before offset
                        // nothing to do
<span class="fc bfc" id="L348" title="All 2 branches covered.">                        if (muStart &gt; deleteToIndex) {</span>
                            // mu is completely after offset
                            // just shift mu
<span class="fc" id="L351">                            mu.setO(mu.getO() + offsetValue);</span>
                        } else {
                            // deletions overlap
<span class="fc bfc" id="L354" title="All 4 branches covered.">                            if (muStart &lt;= deleteFromIndex &amp;&amp; muEnd &gt;= deleteToIndex) {</span>
                                // mu wraps offset
                                // off          |---|
                                // mu       |---------|
                                // new mu   |---     -|
<span class="fc" id="L359">                                mu.setL(mu.getL() + offsetValue);</span>
<span class="fc bfc" id="L360" title="All 4 branches covered.">                            } else if (muStart &gt;= deleteFromIndex &amp;&amp; muEnd &lt;= deleteToIndex) {</span>
                                // offset wraps mu =&gt; mus is useless
                                // off       |---------|
                                // mu          |---|
                                // new mu    canceled
<span class="fc" id="L365">                                microchanges.remove(i);</span>
<span class="fc" id="L366">                                i--;</span>
<span class="pc bpc" id="L367" title="1 of 4 branches missed.">                            } else if (muStart &lt;= deleteFromIndex &amp;&amp; muEnd &lt;= deleteToIndex) {</span>
                                // partial overlap
                                // off       |-----|
                                // mu     |-----|
                                // new mu |--|
<span class="fc" id="L372">                                mu.setL(deleteFromIndex - muStart);</span>
<span class="pc bpc" id="L373" title="2 of 4 branches missed.">                            } else if (muStart &gt;= deleteFromIndex &amp;&amp; muEnd &gt;= deleteToIndex) {</span>
                                // partial overlap
                                // off    |-----|
                                // mu        |-----|
                                // new mu       |--| shifted at offsetStart
<span class="fc" id="L378">                                mu.setL(muEnd - deleteToIndex);</span>
<span class="fc" id="L379">                                mu.setO(deleteFromIndex);</span>
                            } else {
<span class="nc" id="L381">                                logger.error(&quot;Unhandled case offset{}:{}, mu:{}&quot;,</span>
<span class="nc" id="L382">                                    deleteFromIndex, offsetValue, mu);</span>
                            }
                        }
                    }
<span class="pc bpc" id="L386" title="1 of 4 branches missed.">                } else if (offsetValue &lt; 0 &amp;&amp; mu.getT().equals(Type.I)) {</span>
                    // offset is deletion, mu is addition
<span class="fc" id="L388">                    int deleteFromIndex = offsetIndex + offsetValue;</span>
<span class="fc" id="L389">                    int deleteToIndex = offsetIndex;</span>

<span class="fc bfc" id="L391" title="All 2 branches covered.">                    if (muStart &gt;= deleteToIndex) {</span>
                        // off    |-----|
                        // mu               |+++++|
                        // just shift to the left
<span class="fc" id="L395">                        mu.setO(mu.getO() + offsetValue);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">                    } else if (muStart &gt; deleteFromIndex) {</span>
                        // off         |-----|
                        // mu            |+|
                        // mu          |+|
<span class="fc" id="L400">                        mu.setO(deleteFromIndex);</span>
//                    } else {
                        // mu is before offset
                        // off         |-----|
                        // mu     |+|
                        // nothing to do
                    }
<span class="pc bpc" id="L407" title="2 of 4 branches missed.">                } else if (offsetValue &gt; 0 &amp;&amp; mu.getT().equals(Type.D)) {</span>
                    // offset is addition, mu is deletion
<span class="fc" id="L409">                    int muEnd = muStart + mu.getL();</span>

                    // nothing to do if mu is completely before offset
<span class="fc bfc" id="L412" title="All 2 branches covered.">                    if (muEnd &gt;= offsetIndex) {</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">                        if (muStart &gt; offsetIndex) {</span>
                            // off   |+|
                            // mu         |---|
                            // new mu : shift
<span class="fc" id="L417">                            mu.setO(mu.getO() + offsetValue);</span>
                        } else {
                            // off        |+|
                            // mu      |--------|
                            // new v1  |--|  |--|
                            // split mu to preserve addition
<span class="fc" id="L423">                            Integer totalLength = mu.getL();</span>
<span class="fc" id="L424">                            mu.setL(offsetIndex - muStart);</span>
<span class="fc" id="L425">                            MicroChange newMu = new MicroChange();</span>
<span class="fc" id="L426">                            newMu.setT(Type.D);</span>
<span class="fc" id="L427">                            newMu.setO(offsetIndex + offsetValue);</span>
<span class="fc" id="L428">                            newMu.setL(totalLength - mu.getL());</span>
<span class="fc" id="L429">                            microchanges.add(i + 1, newMu);</span>
<span class="fc" id="L430">                            i++;</span>
                        }
                    }
                }
<span class="fc" id="L434">            }</span>
        }

<span class="fc" id="L437">        logger.trace(</span>
            &quot;Shift done: {}&quot;, change);

<span class="fc" id="L440">        return conflictFree;</span>
    }

    /**
     * Compute shifted offset by reflecting changes.
     *
     * @param offsets original offsets
     * @param change  change
     *
     * @return new map of shifted offsets
     */
    private Map&lt;Integer, Integer&gt; shiftOffsets(Map&lt;Integer, Integer&gt; offsets, Change change) {
<span class="fc" id="L452">        Map&lt;Integer, Integer&gt; shifted = new HashMap&lt;&gt;();</span>

<span class="fc" id="L454">        offsets.entrySet().forEach(entry -&gt; {</span>
<span class="fc" id="L455">            Integer offsetIndex = entry.getKey();</span>
<span class="fc" id="L456">            Integer offsetValue = entry.getValue();</span>

<span class="fc" id="L458">            List&lt;MicroChange&gt; muChanges = change.getMicrochanges();</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            for (int i = muChanges.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L460">                MicroChange mu = muChanges.get(i);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">                if (mu.getO() &lt;= offsetIndex) {</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                    if (mu.getT() == MicroChange.Type.D) {</span>
<span class="nc" id="L463">                        offsetIndex -= mu.getL();</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">                    } else if (mu.getT() == MicroChange.Type.I) {</span>
<span class="fc" id="L465">                        offsetIndex += mu.getV().length();</span>
                    }
                }
            }
<span class="fc" id="L469">            shifted.put(offsetIndex, offsetValue);</span>
<span class="fc" id="L470">        });</span>

<span class="fc" id="L472">        return shifted;</span>
    }

    /**
     * Propagate offset to children
     *
     * @param parent  starting point
     * @param offsets offset to propagate
     *
     * @return conflict free propagation or not
     */
    private boolean propagateOffsets(List&lt;Change&gt; changes, Change parent, Map&lt;Integer, Integer&gt; offsets, boolean forward, String offsetFromRev) {
<span class="fc" id="L484">        boolean conflictFree = true;</span>

<span class="fc bfc" id="L486" title="All 2 branches covered.">        for (Change child : getByParent(changes, parent.getRevision())) {</span>
<span class="fc" id="L487">            Set&lt;String&gt; childDeps = getAllDependencies(changes, child);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">            if (!childDeps.contains(offsetFromRev)) {</span>
<span class="fc" id="L489">                logger.debug(&quot;PropagateOffset {}@{} to {}&quot;, offsets, offsetFromRev, child);</span>
                // should propagate to children which are not based on the offsetsFromRev
<span class="fc" id="L491">                boolean shiftFree = this.shift(child, offsets, forward);</span>
<span class="fc" id="L492">                Map&lt;Integer, Integer&gt; shiftedOffsets = shiftOffsets(offsets, child);</span>
<span class="fc" id="L493">                logger.debug(&quot;Shifted Offsets: {}&quot;, shiftedOffsets);</span>
<span class="fc" id="L494">                boolean pFree = this.propagateOffsets(changes, child, shiftedOffsets, forward, offsetFromRev);</span>
<span class="pc bpc" id="L495" title="3 of 6 branches missed.">                conflictFree = conflictFree &amp;&amp; shiftFree &amp;&amp; pFree;</span>
<span class="fc" id="L496">            } else {</span>
                //merge has been done
<span class="fc" id="L498">                HashSet&lt;String&gt; newDeps = new HashSet&lt;&gt;(child.getBasedOn());</span>
<span class="fc" id="L499">                newDeps.remove(offsetFromRev);</span>
<span class="fc" id="L500">                logger.error(&quot;Do not go deeper than {}, now based on {}&quot;, child, newDeps);</span>
<span class="fc" id="L501">                child.setBasedOn(newDeps);</span>
                //child.getBasedOn().remove(offsetFromRev);
            }
<span class="fc" id="L504">        }</span>
<span class="fc" id="L505">        return conflictFree;</span>
    }

    /**
     * Get the full set of revision the given change depends on
     *
     * @param changes full set of changes
     * @param change  the change
     *
     * @return set of dependencies
     */
    private Set&lt;String&gt; getAllDependencies(List&lt;Change&gt; changes, Change change) {
<span class="fc" id="L517">        Set&lt;String&gt; deps = new HashSet&lt;&gt;();</span>

<span class="fc" id="L519">        List&lt;Change&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L520">        queue.add(change);</span>

<span class="fc bfc" id="L522" title="All 2 branches covered.">        while (!queue.isEmpty()) {</span>
<span class="fc" id="L523">            Change ch = queue.remove(0);</span>
<span class="fc" id="L524">            ch.getBasedOn().forEach(dep -&gt; {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                if (!deps.contains(dep)) {</span>
<span class="fc" id="L526">                    deps.add(dep);</span>
<span class="fc" id="L527">                    Change parent = getByRevision(changes, dep);</span>
<span class="pc bpc" id="L528" title="1 of 4 branches missed.">                    if (parent != null &amp;&amp; !queue.contains(parent)) {</span>
<span class="fc" id="L529">                        queue.add(parent);</span>
                    }
                }
<span class="fc" id="L532">            });</span>
<span class="fc" id="L533">        }</span>

<span class="fc" id="L535">        return deps;</span>
    }

    /**
     * Do sets equals?
     *
     * @param a first set
     * @param b second set
     *
     * @return true if sets equal
     */
    private boolean setsEqual(Set&lt;String&gt; a, Set&lt;String&gt; b) {
<span class="pc bpc" id="L547" title="3 of 4 branches missed.">        if (a == null &amp;&amp; b == null) {</span>
            // both null equals
<span class="nc" id="L549">            return true;</span>
<span class="pc bpc" id="L550" title="2 of 4 branches missed.">        } else if (a == null || b == null) {</span>
            // only one is null
<span class="nc" id="L552">            return false;</span>
        } else {
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">            if (a.size() != b.size()) {</span>
<span class="nc" id="L555">                return false;</span>
            }
<span class="fc" id="L557">            return a.containsAll(b);</span>
        }
    }

    /**
     * Move a change to a new base.
     *
     * @param newBase
     * @param change
     * @param offsets
     *
     * @return true if rebase has been done without conflict
     */
    private boolean rebase(List&lt;Change&gt; changes, Change newBase, Change change) {
<span class="fc" id="L571">        Set&lt;String&gt; baseDeps = getAllDependencies(changes, newBase);</span>
<span class="fc" id="L572">        Set&lt;String&gt; changeDeps = getAllDependencies(changes, change);</span>

<span class="pc bpc" id="L574" title="1 of 2 branches missed.">        if (setsEqual(baseDeps, changeDeps)) {</span>
            // exact same set of dependencies: changes are sieblings
<span class="fc" id="L576">            Map&lt;Integer, Integer&gt; offsets = computeOffset(newBase);</span>
<span class="fc" id="L577">            boolean conflictFree = true;</span>
<span class="fc" id="L578">            String newBaseRev = newBase.getRevision();</span>

<span class="fc" id="L580">            logger.debug(&quot;Rebase Sieblings: &quot; + change + &quot; on &quot; + newBase</span>
                + &quot; with offset &quot; + offsets);

<span class="pc bpc" id="L583" title="2 of 4 branches missed.">            conflictFree = shift(change, offsets, true) &amp;&amp; conflictFree;</span>
<span class="pc bpc" id="L584" title="2 of 4 branches missed.">            conflictFree = propagateOffsets(changes, change,</span>
                offsets, true, newBaseRev) &amp;&amp; conflictFree;

            // Update parents after rebase/propagation step
<span class="fc" id="L588">            change.setBasedOn(Set.of(newBase.getRevision()));</span>
<span class="fc" id="L589">            logger.trace(&quot; -&gt; &quot; + change);</span>
<span class="fc" id="L590">            return conflictFree;</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        } else if (setsEqual(Set.of(change.getRevision()), newBase.getBasedOn())) {</span>
<span class="nc" id="L592">            logger.debug(&quot;Inverse hierarchy : &quot; + change + &quot; on &quot; + newBase);</span>
            // [x] -&gt; change -&gt; newBase
            // ==&gt;[x] -&gt;  newBase -&gt; change

<span class="nc" id="L596">            boolean conflictFree = true;</span>

<span class="nc" id="L598">            Map&lt;Integer, Integer&gt; changeOffsets = computeOffset(change);</span>

<span class="nc" id="L600">            newBase.setBasedOn(change.getBasedOn());</span>
<span class="nc" id="L601">            change.setBasedOn(Set.of(newBase.getRevision()));</span>

<span class="nc bnc" id="L603" title="All 4 branches missed.">            conflictFree = shift(newBase, changeOffsets, false) &amp;&amp; conflictFree;</span>

<span class="nc" id="L605">            Map&lt;Integer, Integer&gt; newBaseOffsets = computeOffset(newBase);</span>
<span class="nc bnc" id="L606" title="All 4 branches missed.">            conflictFree = shift(change, newBaseOffsets, true) &amp;&amp; conflictFree;</span>

<span class="nc" id="L608">            logger.trace(&quot; with offsets &quot; + changeOffsets + &quot; and &quot; + newBaseOffsets);</span>
<span class="nc" id="L609">            logger.trace(&quot; -&gt; &quot; + change);</span>

<span class="nc" id="L611">            return conflictFree;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">        } else if (changeDeps.containsAll(baseDeps)) {</span>
            // nothing to do as all deps are already known
<span class="nc" id="L614">            logger.info(&quot;Nothing to do: change includes all base parents&quot;);</span>
<span class="nc" id="L615">            return true;</span>
        } else {
<span class="nc" id="L617">            logger.error(&quot;Not yet implemented: Changes: {} Change: {} NewBase: {} BaseDeps: {} ChangeDeps: {}&quot;, changes, change.getRevision(), newBase.getRevision(), baseDeps, changeDeps);</span>
<span class="nc" id="L618">            return false;</span>
        }
    }

    /**
     * FIlter list of change and return only those which match the given live session
     *
     * @param changes list of changes
     * @param author  live-session id
     *
     * @return list of changes authored by the given author
     */
    public List&lt;Change&gt; filterByAuthor(List&lt;Change&gt; changes, String author) {
<span class="nc" id="L631">        return changes.stream()</span>
<span class="nc" id="L632">            .filter(child</span>
<span class="nc" id="L633">                -&gt; child.getLiveSession().equals(author))</span>
<span class="nc" id="L634">            .collect(Collectors.toList());</span>
    }

    private List&lt;String&gt; mapChangesRevision(Collection&lt;Change&gt; changes) {
<span class="fc" id="L638">        return changes.stream().map(Change::getRevision).collect(Collectors.toList());</span>
    }

    /**
     * Apply all changes.
     *
     * @param strict to be implemented: fail when there is some conflicts or not
     *
     * @return up-to date content
     */
    public LiveResult process(boolean strict) {
<span class="fc" id="L649">        StringBuilder buffer = new StringBuilder();</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (this.content != null) {</span>
<span class="fc" id="L651">            buffer.append(this.content);</span>
        }

<span class="fc" id="L654">        logger.trace(&quot;Process: {}&quot;, this);</span>

<span class="fc" id="L656">        String currentRevision = this.revision;</span>

<span class="fc" id="L658">        List&lt;Change&gt; allChanges = this.getPendingChanges();</span>
<span class="fc" id="L659">        List&lt;Change&gt; changes = new ArrayList&lt;&gt;(allChanges);</span>

<span class="fc" id="L661">        Set&lt;String&gt; appliedChanges = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">        while (!changes.isEmpty()) {</span>
<span class="fc" id="L664">            appliedChanges.add(currentRevision);</span>
            // fetch all changes based on the current revision
<span class="fc" id="L666">            List&lt;Change&gt; children = getByParent(changes, currentRevision);</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">            if (!children.isEmpty()) {</span>
                //Map&lt;Integer, Integer&gt; offsets = new HashMap&lt;&gt;();
                //logger.trace(&quot;new empty offsets &quot; + offsets);
<span class="fc" id="L670">                logger.debug(&quot;All @{} children: {}&quot;, currentRevision, mapChangesRevision(children));</span>

                // find a child which depends only only already applied changes
                // NB: as I understand the algorithm, I can't figure out a case
                //     such a child-with-unapplied-parent may event exists...
<span class="fc" id="L675">                Optional&lt;Change&gt; optChange = children.stream()</span>
<span class="fc" id="L676">                    .filter(ch -&gt; appliedChanges.containsAll(ch.getBasedOn()))</span>
<span class="fc" id="L677">                    .findFirst();</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                if (optChange.isPresent()) {</span>
<span class="fc" id="L679">                    Change change = optChange.get();</span>
                    // clean lists
<span class="fc" id="L681">                    changes.remove(change);</span>
<span class="fc" id="L682">                    children.remove(change);</span>

<span class="fc" id="L684">                    logger.debug(&quot;Process: {}&quot;, change);</span>

<span class="fc" id="L686">                    List&lt;MicroChange&gt; muChanges = change.getMicrochanges();</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                    for (int i = muChanges.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L688">                        applyChange(buffer, muChanges.get(i));</span>
<span class="fc" id="L689">                        logger.trace(&quot;  &quot; + i + &quot;)&quot; + buffer);</span>
                    }

<span class="fc" id="L692">                    logger.debug(&quot; -&gt; {}&quot;, buffer);</span>
                    //logger.trace(&quot;Offsets&quot; + offsets);
                    // rebase others children

<span class="fc" id="L696">                    changes.removeAll(children);</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">                    for (int i = children.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L698">                        Change child = children.remove(i);</span>
<span class="pc bpc" id="L699" title="3 of 4 branches missed.">                        if (!rebase(allChanges, change, child) &amp;&amp; strict) {</span>
                            // todo throw ?
<span class="nc" id="L701">                            logger.error(&quot;Conflict&quot;);</span>
                        }
<span class="fc" id="L703">                        changes.add(0, child);</span>
                    }
<span class="fc" id="L705">                    currentRevision = change.getRevision();</span>
<span class="fc" id="L706">                } else {</span>
<span class="nc" id="L707">                    logger.error(&quot;No child found in {}&quot;, children);</span>
<span class="nc" id="L708">                    break;</span>
                }

<span class="fc" id="L711">            } else {</span>
<span class="nc" id="L712">                logger.error(&quot;Some children without any parents left: {}&quot;, changes);</span>
<span class="nc" id="L713">                break;</span>
            }
<span class="fc" id="L715">        }</span>

<span class="fc" id="L717">        return LiveResult.build(buffer.toString(), currentRevision);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L722">        return &quot;LiveUpdates{&quot; + &quot;targetClass=&quot; + targetClass + &quot;, targetId=&quot; + targetId + &quot;, revision=&quot; + revision + &quot;, content=&quot; + content + &quot;, pendingChanges=&quot; + pendingChanges + '}';</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>