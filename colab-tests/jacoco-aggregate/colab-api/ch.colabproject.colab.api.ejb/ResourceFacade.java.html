<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ResourceFacade.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-tests</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.ejb</a> &gt; <span class="el_source">ResourceFacade.java</span></div><h1>ResourceFacade.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.ejb;

import ch.colabproject.colab.api.model.card.AbstractCardType;
import ch.colabproject.colab.api.model.card.Card;
import ch.colabproject.colab.api.model.card.CardContent;
import ch.colabproject.colab.api.model.document.AbstractResource;
import ch.colabproject.colab.api.model.document.Document;
import ch.colabproject.colab.api.model.document.Resource;
import ch.colabproject.colab.api.model.document.ResourceRef;
import ch.colabproject.colab.api.model.link.StickyNoteLink;
import ch.colabproject.colab.api.persistence.card.CardContentDao;
import ch.colabproject.colab.api.persistence.card.CardDao;
import ch.colabproject.colab.api.persistence.card.CardTypeDao;
import ch.colabproject.colab.api.persistence.document.AbstractResourceDao;
import ch.colabproject.colab.api.persistence.document.ResourceDao;
import ch.colabproject.colab.api.persistence.document.ResourceRefDao;
import ch.colabproject.colab.generator.model.exceptions.HttpErrorMessage;
import com.google.common.base.Strings;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.inject.Inject;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Resource and resource reference specific logic
 *
 * @author sandra
 */
// TODO refine the publish / deprecated / refused effect
// TODO requestingForGlory handling
// TODO !!!! deal with abstract card type
@Stateless
@LocalBean
<span class="fc" id="L45">public class ResourceFacade {</span>

    /** logger */
<span class="fc" id="L48">    private static final Logger logger = LoggerFactory.getLogger(ResourceFacade.class);</span>

    // *********************************************************************************************
    // injections
    // *********************************************************************************************

    /**
     * Resource persistence handling
     */
    @Inject
    private ResourceDao resourceDao;

    /**
     * Resource reference persistence handling
     */
    @Inject
    private ResourceRefDao resourceRefDao;

    /**
     * Resource / resource reference persistence handling
     */
    @Inject
    private AbstractResourceDao resourceOrRefDao;

    /**
     * Card type and card type reference persistence handling
     */
    @Inject
    private CardTypeDao cardTypeDao;

    /**
     * Card persistence
     */
    @Inject
    private CardDao cardDao;

    /**
     * Card content persistence handling
     */
    @Inject
    private CardContentDao cardContentDao;

    // *********************************************************************************************
    // resource access stuff
    // *********************************************************************************************

    /**
     * Find every resource directly linked or linked by reference to the card type.
     * &lt;p&gt;
     * The resources must be active and available for the card type.
     *
     * @param abstractCardTypeId the id of the card type or card type reference
     *
     * @return all resources that match
     */
    public List&lt;Resource&gt; getAvailableActiveResourcesLinkedToAbstractCardType(
        Long abstractCardTypeId) {
<span class="nc" id="L105">        logger.debug(&quot;Get available active resources linked to abstract card type #{}&quot;,</span>
            abstractCardTypeId);

<span class="nc" id="L108">        AbstractCardType cardTypeOrRef = cardTypeDao.getAbstractCardType(abstractCardTypeId);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (cardTypeOrRef == null) {</span>
<span class="nc" id="L110">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="nc" id="L113">        return findAvailableAndActiveTargetResource(cardTypeOrRef.getDirectAbstractResources());</span>
    }

    /**
     * Find every resource directly linked or linked by reference to the card.
     * &lt;p&gt;
     * The resources must be active and available for the card.
     *
     * @param cardId the id of the card
     *
     * @return all resources that match
     */
    public List&lt;Resource&gt; getAvailableActiveResourcesLinkedToCard(Long cardId) {
<span class="nc" id="L126">        logger.debug(&quot;Get available active resources linked to card #{}&quot;, cardId);</span>

<span class="nc" id="L128">        Card card = cardDao.getCard(cardId);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (card == null) {</span>
<span class="nc" id="L130">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="nc" id="L133">        return findAvailableAndActiveTargetResource(card.getDirectAbstractResources());</span>
    }

    /**
     * Find every resource directly linked or linked by reference to the card content.
     * &lt;p&gt;
     * The resources must be active and available for the card content.
     *
     * @param cardContentId the id of the card content
     *
     * @return all resources that match
     */
    public List&lt;Resource&gt; getAvailableActiveResourcesLinkedToCardContent(Long cardContentId) {
<span class="nc" id="L146">        logger.debug(&quot;Get available active resources linked to card content #{}&quot;, cardContentId);</span>

<span class="nc" id="L148">        CardContent cardContent = cardContentDao.getCardContent(cardContentId);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (cardContent == null) {</span>
<span class="nc" id="L150">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="nc" id="L153">        return findAvailableAndActiveTargetResource(cardContent.getDirectAbstractResources());</span>
    }

    /**
     * Find the resources at the end of the references chains.
     * &lt;p&gt;
     * Only the active and available resources are taken into account.
     *
     * @param baseAbstractResources The list of abstract resources to search from
     *
     * @return the resources that match
     */
    private List&lt;Resource&gt; findAvailableAndActiveTargetResource(
        List&lt;AbstractResource&gt; baseAbstractResources) {
<span class="nc" id="L167">        List&lt;Resource&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (AbstractResource abstractResource : baseAbstractResources) {</span>
<span class="nc" id="L170">            Resource resource = getAvailableActiveResource(abstractResource);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (resource != null) {</span>
<span class="nc" id="L172">                result.add(resource);</span>
            }
<span class="nc" id="L174">        }</span>

<span class="nc" id="L176">        return result;</span>
    }

    /**
     * Recursive method to get the resource at the end of each references chain.
     * &lt;p&gt;
     * Only the active and available resources are taken into account.
     *
     * @param abstractResource An abstract resource
     *
     * @return the resource at the end of each references chain as long as it is available and
     *         active
     */
    private Resource getAvailableActiveResource(AbstractResource abstractResource) {
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (abstractResource instanceof Resource) {</span>
<span class="nc" id="L191">            return (Resource) abstractResource;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        } else if (abstractResource instanceof ResourceRef) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (isResourceAvailableAndActive((ResourceRef) abstractResource)) {</span>
<span class="nc" id="L194">                return getAvailableActiveResource(</span>
<span class="nc" id="L195">                    ((ResourceRef) abstractResource).getTarget());</span>
            }
        } else {
<span class="nc" id="L198">            throw HttpErrorMessage.dataIntegrityFailure();</span>
        }

<span class="nc" id="L201">        return null;</span>
    }

    /**
     * Filter to only take into account resources that are available and active
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;a resource must be published to be passed the sub cards&lt;/li&gt;
     * &lt;li&gt;the reference must not be refused&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param resourceRef the resource reference
     *
     * @return whether the resource can be taken into account or not
     */
    private boolean isResourceAvailableAndActive(ResourceRef resourceRef) {
<span class="nc" id="L217">        AbstractResource target = resourceRef.getTarget();</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">        if (resourceRef.hasCard() &amp;&amp; target.hasCardContent()</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            &amp;&amp; !resourceRef.resolve().isPublished()) {</span>
<span class="nc" id="L220">            return false;</span>
        }

<span class="nc bnc" id="L223" title="All 2 branches missed.">        return !resourceRef.isRefused();</span>
    }

    /**
     * Get all abstract resources of a given card type.
     *
     * @param abstractCardTypeId the id of the card type
     *
     * @return all abstract resources directly linked to the card type
     */
    public List&lt;AbstractResource&gt; getDirectAbstractResourcesOfAbstractCardType(
        Long abstractCardTypeId) {
<span class="nc" id="L235">        logger.debug(&quot;get abstract resources directly linked to abstract card type #{}&quot;,</span>
            abstractCardTypeId);
<span class="nc" id="L237">        AbstractCardType abstractCardType = cardTypeDao.getAbstractCardType(abstractCardTypeId);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (abstractCardType == null) {</span>
<span class="nc" id="L239">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }
<span class="nc" id="L241">        return abstractCardType.getDirectAbstractResources();</span>
    }

    /**
     * Get all abstract resources of a given card.
     *
     * @param cardId the id of the card
     *
     * @return all abstract resources directly linked to the card
     */
    public List&lt;AbstractResource&gt; getDirectAbstractResourcesOfCard(Long cardId) {
<span class="nc" id="L252">        logger.debug(&quot;get abstract resources directly linked to card #{}&quot;, cardId);</span>
<span class="nc" id="L253">        Card card = cardDao.getCard(cardId);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (card == null) {</span>
<span class="nc" id="L255">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }
<span class="nc" id="L257">        return card.getDirectAbstractResources();</span>
    }

    /**
     * Get all abstract resources of a given card content.
     *
     * @param cardContentId the id of the card content
     *
     * @return all abstract resources directly linked to the card content
     */
    public List&lt;AbstractResource&gt; getDirectAbstractResourcesOfCardContent(Long cardContentId) {
<span class="nc" id="L268">        logger.debug(&quot;get abstract resources directly linked to card content #{}&quot;, cardContentId);</span>
<span class="nc" id="L269">        CardContent cardContent = cardContentDao.getCardContent(cardContentId);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (cardContent == null) {</span>
<span class="nc" id="L271">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }
<span class="nc" id="L273">        return cardContent.getDirectAbstractResources();</span>
    }

    /**
     * Retrieve the abstract resources directly linked to an abstract card type and all the chain of
     * references to the concrete resource
     *
     * @param cardTypeOrRefId The id of the card type or reference
     *
     * @return For each abstract resource, the chain of abstract resources to the resource
     */
    public List&lt;List&lt;AbstractResource&gt;&gt; getResourceChainForAbstractCardType(Long cardTypeOrRefId) {
<span class="fc" id="L285">        logger.debug(&quot;get resource chain linked to abstract card type #{}&quot;, cardTypeOrRefId);</span>

<span class="fc" id="L287">        AbstractCardType cardTypeOrRef = cardTypeDao.getAbstractCardType(cardTypeOrRefId);</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (cardTypeOrRef == null) {</span>
<span class="nc" id="L289">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L292">        List&lt;AbstractResource&gt; directResourceOrRefs = cardTypeOrRef.getDirectAbstractResources();</span>

<span class="fc" id="L294">        return expandCompleteChain(directResourceOrRefs);</span>
    }

    /**
     * Retrieve the abstract resources directly linked to a card and all the chain of references to
     * the concrete resource
     *
     * @param cardId The id of the card
     *
     * @return For each abstract resource, the chain of abstract resources until the resource
     */
    public List&lt;List&lt;AbstractResource&gt;&gt; getResourceChainForCard(Long cardId) {
<span class="fc" id="L306">        logger.debug(&quot;get resource chain linked to card #{}&quot;, cardId);</span>

<span class="fc" id="L308">        Card card = cardDao.getCard(cardId);</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (card == null) {</span>
<span class="nc" id="L310">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L313">        List&lt;AbstractResource&gt; directResourceOrRefs = card.getDirectAbstractResources();</span>

<span class="fc" id="L315">        return expandCompleteChain(directResourceOrRefs);</span>
    }

    /**
     * Retrieve the abstract resources directly linked to a card content and all the chain of
     * references to the concrete resource
     *
     * @param cardContentId The id of the card content
     *
     * @return For each abstract resource, the chain of abstract resources until the resource
     */
    public List&lt;List&lt;AbstractResource&gt;&gt; getResourceChainForCardContent(Long cardContentId) {
<span class="fc" id="L327">        logger.debug(&quot;get resource chain linked to card content #{}&quot;, cardContentId);</span>

<span class="fc" id="L329">        CardContent cardContent = cardContentDao.getCardContent(cardContentId);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (cardContent == null) {</span>
<span class="nc" id="L331">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L334">        List&lt;AbstractResource&gt; directResourceOrRefs = cardContent.getDirectAbstractResources();</span>

<span class="fc" id="L336">        return expandCompleteChain(directResourceOrRefs);</span>
    }

    private List&lt;List&lt;AbstractResource&gt;&gt; expandCompleteChain(
        List&lt;AbstractResource&gt; directResourceOrRefs) {
<span class="fc" id="L341">        List&lt;List&lt;AbstractResource&gt;&gt; allResults = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L342">        directResourceOrRefs.forEach(resourceOrRef -&gt; {</span>
<span class="fc" id="L343">            allResults.add(resourceOrRef.expand());</span>
<span class="fc" id="L344">        });</span>

<span class="fc" id="L346">        return allResults;</span>
    }

    // *********************************************************************************************
    // resource creation stuff
    // *********************************************************************************************

    /**
     * Create a new resource for the document linked to the card type (or card type reference).
     * &lt;p&gt;
     * Every child of the card type (recursively) acquires a reference to that resource or, for the
     * grandchildren, to a reference to that resource.
     *
     * @param document   the document the resource represents
     * @param cardTypeId the id of the card type the resource must be linked to
     * @param category   the category of the resource (for organization purpose)
     *
     * @return the brand new resource
     */
    public Resource createResourceForAbstractCardType(Document document, Long cardTypeId,
        String category) {
<span class="fc" id="L367">        logger.debug(</span>
            &quot;create a resource for document {} and an abstract card type #{} with category {}&quot;,
            document, cardTypeId, category);

<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (document == null) {</span>
<span class="nc" id="L372">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

        // A document can be related at max to one resource
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (document.hasResource()) {</span>
<span class="nc" id="L377">            throw HttpErrorMessage.dataIntegrityFailure();</span>
        }

<span class="fc" id="L380">        AbstractCardType abstractCardType = cardTypeDao.getAbstractCardType(cardTypeId);</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (abstractCardType == null) {</span>
<span class="nc" id="L382">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L385">        Resource resource = Resource.initNewResource();</span>

<span class="fc" id="L387">        resource.setAbstractCardType(abstractCardType);</span>
<span class="fc" id="L388">        abstractCardType.getDirectAbstractResources().add(resource);</span>

<span class="fc" id="L390">        resource.setDocument(document);</span>
<span class="fc" id="L391">        document.setResource(resource);</span>

<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (!Strings.isNullOrEmpty(category)) {</span>
<span class="fc" id="L394">            resource.setCategory(category);</span>
        }

<span class="fc" id="L397">        resource = resourceDao.persistResource(resource);</span>

<span class="fc" id="L399">        createResourceRefForChildren(abstractCardType, resource);</span>

<span class="fc" id="L401">        return resource;</span>
    }

    /**
     * Create a new resource for the document linked to the card
     * &lt;p&gt;
     * Every child of the card (recursively) acquires a reference to that resource or, for the
     * grandchildren, to a reference to that resource
     *
     * @param document the document the resource represents
     * @param cardId   the id of the card the resource must be linked to
     * @param category the category of the resource (for organization purpose)
     *
     * @return the brand new resource
     */
    public Resource createResourceForCard(Document document, Long cardId, String category) {
<span class="fc" id="L417">        logger.debug(&quot;create a resource for document {} and card #{} with category {}&quot;,</span>
            document, cardId, category);

<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        if (document == null) {</span>
<span class="nc" id="L421">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

        // A document can be related at max to one resource
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (document.hasResource()) {</span>
<span class="nc" id="L426">            throw HttpErrorMessage.dataIntegrityFailure();</span>
        }

<span class="fc" id="L429">        Card card = cardDao.getCard(cardId);</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">        if (card == null) {</span>
<span class="nc" id="L431">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L434">        Resource resource = Resource.initNewResource();</span>

<span class="fc" id="L436">        resource.setCard(card);</span>
<span class="fc" id="L437">        card.getDirectAbstractResources().add(resource);</span>

<span class="fc" id="L439">        resource.setDocument(document);</span>
<span class="fc" id="L440">        document.setResource(resource);</span>

<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (!Strings.isNullOrEmpty(category)) {</span>
<span class="fc" id="L443">            resource.setCategory(category);</span>
        }

<span class="fc" id="L446">        resource = resourceDao.persistResource(resource);</span>

<span class="fc" id="L448">        createResourceRefForChildren(card, resource);</span>

<span class="fc" id="L450">        return resource;</span>
    }

    /**
     * Create a new resource for the document linked to the card content
     * &lt;p&gt;
     * Every child of the card content (recursively) acquires a reference to that resource or, for
     * the grandchildren, to a reference to that resource
     *
     * @param document      the document the resource represents
     * @param cardContentId the id of the card content the resource must be linked to
     * @param category      the category of the resource (for organization purpose)
     *
     * @return the brand new resource
     */
    public Resource createResourceForCardContent(Document document, Long cardContentId,
        String category) {
<span class="fc" id="L467">        logger.debug(&quot;create a resource for document {} and card content #{} with category {}&quot;,</span>
            document, cardContentId, category);

<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (document == null) {</span>
<span class="nc" id="L471">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

        // A document can be related at max to one resource
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (document.hasResource()) {</span>
<span class="nc" id="L476">            throw HttpErrorMessage.dataIntegrityFailure();</span>
        }

<span class="fc" id="L479">        CardContent cardContent = cardContentDao.getCardContent(cardContentId);</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (cardContent == null) {</span>
<span class="nc" id="L481">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L484">        Resource resource = Resource.initNewResource();</span>

<span class="fc" id="L486">        resource.setCardContent(cardContent);</span>
<span class="fc" id="L487">        cardContent.getDirectAbstractResources().add(resource);</span>

<span class="fc" id="L489">        resource.setDocument(document);</span>
<span class="fc" id="L490">        document.setResource(resource);</span>

<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(category)) {</span>
<span class="fc" id="L493">            resource.setCategory(category);</span>
        }

<span class="fc" id="L496">        resource = resourceDao.persistResource(resource);</span>

<span class="fc" id="L498">        createResourceRefForChildren(cardContent, resource);</span>

<span class="fc" id="L500">        return resource;</span>
    }

    /**
     * Each child of the card type acquires a reference to the resource.
     *
     * @param cardTypeOrRef the card type or card type reference
     * @param resource the resource we are linking
     */
    private void createResourceRefForChildren(AbstractCardType cardTypeOrRef,
        AbstractResource resource) {
<span class="fc bfc" id="L511" title="All 2 branches covered.">        for (AbstractCardType cardTypeRef : cardTypeOrRef.getDirectReferences()) {</span>
<span class="fc" id="L512">            ResourceRef resourceRef = ResourceRef.initNewResourceRef();</span>

<span class="fc" id="L514">            resourceRef.setTarget(resource);</span>
<span class="fc" id="L515">            resource.getDirectReferences().add(resourceRef);</span>

<span class="fc" id="L517">            resourceRef.setAbstractCardType(cardTypeRef);</span>
<span class="fc" id="L518">            cardTypeRef.getDirectAbstractResources().add(resourceRef);</span>

<span class="fc" id="L520">            resourceRefDao.persistResourceRef(resourceRef);</span>

<span class="fc" id="L522">            createResourceRefForChildren(cardTypeRef, resourceRef);</span>
<span class="fc" id="L523">        }</span>

<span class="fc bfc" id="L525" title="All 2 branches covered.">        for (Card card : cardTypeOrRef.getImplementingCards()) {</span>
<span class="fc" id="L526">            ResourceRef cardResourceRef = ResourceRef.initNewResourceRef();</span>

<span class="fc" id="L528">            cardResourceRef.setTarget(resource);</span>
<span class="fc" id="L529">            resource.getDirectReferences().add(cardResourceRef);</span>

<span class="fc" id="L531">            cardResourceRef.setCard(card);</span>
<span class="fc" id="L532">            card.getDirectAbstractResources().add(cardResourceRef);</span>

<span class="fc" id="L534">            resourceRefDao.persistResourceRef(cardResourceRef);</span>

<span class="fc bfc" id="L536" title="All 2 branches covered.">            for (CardContent cardContent : card.getContentVariants()) {</span>
<span class="fc" id="L537">                ResourceRef cardContentResourceRef = ResourceRef.initNewResourceRef();</span>

<span class="fc" id="L539">                cardContentResourceRef.setTarget(cardResourceRef);</span>
<span class="fc" id="L540">                cardResourceRef.getDirectReferences().add(cardContentResourceRef);</span>

<span class="fc" id="L542">                cardContentResourceRef.setCardContent(cardContent);</span>
<span class="fc" id="L543">                cardContent.getDirectAbstractResources().add(cardContentResourceRef);</span>

<span class="fc" id="L545">                resourceRefDao.persistResourceRef(cardContentResourceRef);</span>
<span class="fc" id="L546">            }</span>
<span class="fc" id="L547">        }</span>
<span class="fc" id="L548">    }</span>

    /**
     * Each child of the card acquires a reference to the resource.
     *
     * @param card     the card
     * @param resource the resource we are linking
     */
    private void createResourceRefForChildren(Card card, AbstractResource resource) {
<span class="fc bfc" id="L557" title="All 2 branches covered.">        for (CardContent cardContent : card.getContentVariants()) {</span>
<span class="fc" id="L558">            ResourceRef resourceRef = ResourceRef.initNewResourceRef();</span>

<span class="fc" id="L560">            resourceRef.setTarget(resource);</span>
<span class="fc" id="L561">            resource.getDirectReferences().add(resourceRef);</span>

<span class="fc" id="L563">            resourceRef.setCardContent(cardContent);</span>
<span class="fc" id="L564">            cardContent.getDirectAbstractResources().add(resourceRef);</span>

<span class="fc" id="L566">            resourceRefDao.persistResourceRef(resourceRef);</span>

<span class="fc" id="L568">            createResourceRefForChildren(cardContent, resourceRef);</span>
<span class="fc" id="L569">        }</span>
<span class="fc" id="L570">    }</span>

    /**
     * Each child of the card content acquires a reference to the resource.
     *
     * @param cardContent the card content
     * @param resource    the resource we are linking
     */
    private void createResourceRefForChildren(CardContent cardContent, AbstractResource resource) {
<span class="fc bfc" id="L579" title="All 2 branches covered.">        for (Card card : cardContent.getSubCards()) {</span>
<span class="fc" id="L580">            ResourceRef resourceRef = ResourceRef.initNewResourceRef();</span>

<span class="fc" id="L582">            resourceRef.setTarget(resource);</span>
<span class="fc" id="L583">            resource.getDirectReferences().add(resourceRef);</span>

<span class="fc" id="L585">            resourceRef.setCard(card);</span>
<span class="fc" id="L586">            card.getDirectAbstractResources().add(resourceRef);</span>

<span class="fc" id="L588">            resourceRefDao.persistResourceRef(resourceRef);</span>

<span class="fc" id="L590">            createResourceRefForChildren(card, resourceRef);</span>
<span class="fc" id="L591">        }</span>
<span class="fc" id="L592">    }</span>

    // *********************************************************************************************
    // deletion
    // *********************************************************************************************

    /**
     * Delete a resource
     *
     * @param resourceId the id of the resource to delete
     */
    public void deleteResource(Long resourceId) {
<span class="fc" id="L604">        logger.debug(&quot;delete resource #{}&quot;, resourceId);</span>

<span class="fc" id="L606">        AbstractResource resource = resourceOrRefDao.findResourceOrRef(resourceId);</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        if (resource == null) {</span>
<span class="nc" id="L608">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
            // or just return. see what is best
        }

<span class="pc bpc" id="L612" title="1 of 2 branches missed.">        if (!(resource instanceof Resource)) {</span>
<span class="nc" id="L613">            throw HttpErrorMessage.dataIntegrityFailure();</span>
        }

<span class="fc" id="L616">        deleteResourceAndRefs(resource);</span>

        // Note : the document is deleted by cascade
<span class="fc" id="L619">    }</span>

    /**
     * Delete each reference pointing at the given resourceOrRef
     *
     * @param resourceOrRef The initial abstract resource to delete
     */
    private void deleteResourceAndRefs(AbstractResource resourceOrRef) {
<span class="fc" id="L627">        List&lt;ResourceRef&gt; references = resourceOrRef.getDirectReferences();</span>
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">        if (references != null) {</span>
<span class="fc" id="L629">            references.stream().forEach(ref -&gt; deleteResourceAndRefs(ref));</span>
        }

<span class="fc bfc" id="L632" title="All 2 branches covered.">        if (resourceOrRef.hasAbstractCardType()) {</span>
<span class="fc" id="L633">            AbstractCardType cardTypeOrRef = resourceOrRef.getAbstractCardType();</span>
<span class="fc" id="L634">            cardTypeOrRef.getDirectAbstractResources().remove(resourceOrRef);</span>
        }

<span class="fc bfc" id="L637" title="All 2 branches covered.">        if (resourceOrRef.hasCard()) {</span>
<span class="fc" id="L638">            Card card = resourceOrRef.getCard();</span>
<span class="fc" id="L639">            card.getDirectAbstractResources().remove(resourceOrRef);</span>
        }

<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (resourceOrRef.hasCardContent()) {</span>
<span class="fc" id="L643">            CardContent cardContent = resourceOrRef.getCardContent();</span>
<span class="fc" id="L644">            cardContent.getDirectAbstractResources().remove(resourceOrRef);</span>
        }

<span class="fc" id="L647">        resourceOrRefDao.deleteResourceOrRef(resourceOrRef.getId());</span>
<span class="fc" id="L648">    }</span>

    // *********************************************************************************************
    // Category stuff
    // *********************************************************************************************

    /**
     * Set the category of the resource
     *
     * @param resourceOrRefId the id of the resource / resource reference
     * @param categoryName    the name of the category that apply to the resource / resource
     *                        reference
     */
    public void setCategory(Long resourceOrRefId, String categoryName) {
<span class="fc" id="L662">        logger.debug(&quot;set category {} to abstract resource #{}&quot;, categoryName, resourceOrRefId);</span>

<span class="pc bpc" id="L664" title="1 of 2 branches missed.">        if (StringUtils.isBlank(categoryName)) {</span>
<span class="nc" id="L665">            removeCategory(resourceOrRefId);</span>
        } else {
<span class="fc" id="L667">            AbstractResource resourceOrRef = resourceOrRefDao.findResourceOrRef(resourceOrRefId);</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">            if (resourceOrRef == null) {</span>
<span class="nc" id="L669">                throw HttpErrorMessage.relatedObjectNotFoundError();</span>
            }

<span class="fc" id="L672">            resourceOrRef.setCategory(categoryName);</span>
        }
<span class="fc" id="L674">    }</span>

    /**
     * Set the category of a list of resources
     *
     * @param resourceOrRefIds the id of the resources / resource references
     * @param categoryName     the name of the category that apply to the resource / resource
     *                         reference
     */
    public void setCategory(List&lt;Long&gt; resourceOrRefIds, String categoryName) {
<span class="fc" id="L684">        logger.debug(&quot;set category {} to abstract resources #{}&quot;, categoryName, resourceOrRefIds);</span>

<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (StringUtils.isBlank(categoryName)) {</span>
<span class="fc" id="L687">            removeCategory(resourceOrRefIds);</span>
        } else {
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">            if (resourceOrRefIds == null) {</span>
<span class="nc" id="L690">                throw HttpErrorMessage.relatedObjectNotFoundError();</span>
            }

<span class="fc" id="L693">            resourceOrRefIds.stream().forEach(resOrRefId -&gt; setCategory(resOrRefId, categoryName));</span>
        }
<span class="fc" id="L695">    }</span>

    /**
     * Remove the category of the resource / resource reference
     *
     * @param resourceOrRefId the id of the resource / resource reference
     */
    public void removeCategory(Long resourceOrRefId) {
<span class="fc" id="L703">        logger.debug(&quot;remove category of abstract resource #{}&quot;, resourceOrRefId);</span>

<span class="fc" id="L705">        AbstractResource resourceOrRef = resourceOrRefDao.findResourceOrRef(resourceOrRefId);</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">        if (resourceOrRef == null) {</span>
<span class="nc" id="L707">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L710">        resourceOrRef.setCategory(null);</span>
<span class="fc" id="L711">    }</span>

    /**
     * Remove the category of a list of resources / resource references
     *
     * @param resourceOrRefIds the id of the resources / resource references
     */
    public void removeCategory(List&lt;Long&gt; resourceOrRefIds) {
<span class="fc" id="L719">        logger.debug(&quot;remove category to abstract resources #{}&quot;, resourceOrRefIds);</span>

<span class="pc bpc" id="L721" title="1 of 2 branches missed.">        if (resourceOrRefIds == null) {</span>
<span class="nc" id="L722">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L725">        resourceOrRefIds.stream().forEach(resOrRefId -&gt; removeCategory(resOrRefId));</span>
<span class="fc" id="L726">    }</span>

    /**
     * Rename the category in a card type / card type reference
     *
     * @param cardTypeOrRefId the id of the card type / card type reference (scope of the renaming)
     * @param projectId       the id of the project concerned (scope of the renaming)
     * @param oldName         the old name of the category
     * @param newName         the new name of the category
     */
    public void renameCategoryInCardType(Long cardTypeOrRefId, Long projectId, String oldName,
        String newName) {
<span class="fc" id="L738">        logger.debug(&quot;rename category {} to {} in the abstract card type #{}&quot;, oldName, newName,</span>
            cardTypeOrRefId);

<span class="fc" id="L741">        AbstractCardType cardTypeOrRef = cardTypeDao.getAbstractCardType(cardTypeOrRefId);</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if (cardTypeOrRef == null) {</span>
<span class="nc" id="L743">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L746">        Long effectiveProjectId = projectId;</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        if (projectId == null) {</span>
<span class="nc" id="L748">            effectiveProjectId = cardTypeOrRef.getProjectId();</span>
        }

<span class="fc" id="L751">        renameCategory(cardTypeOrRef, effectiveProjectId, oldName, newName);</span>
<span class="fc" id="L752">    }</span>

    /**
     * Rename the category in a card
     *
     * @param cardId  the id of the card
     * @param oldName the old name of the category
     * @param newName the new name of the category
     */
    public void renameCategoryInCard(Long cardId, String oldName, String newName) {
<span class="fc" id="L762">        logger.debug(&quot;rename category {} to {} in the card #{}&quot;, oldName, newName, cardId);</span>

<span class="fc" id="L764">        Card card = cardDao.getCard(cardId);</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">        if (card == null) {</span>
<span class="nc" id="L766">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L769">        renameCategory(card, oldName, newName);</span>
<span class="fc" id="L770">    }</span>

    /**
     * Rename the category in a card content
     *
     * @param cardContentId the id of the card content
     * @param oldName       the old name of the category
     * @param newName       the new name of the category
     */
    public void renameCategoryInCardContent(Long cardContentId, String oldName, String newName) {
<span class="fc" id="L780">        logger.debug(&quot;rename category {} to {} in the card content #{}&quot;, oldName, newName,</span>
            cardContentId);

<span class="fc" id="L783">        CardContent cardContent = cardContentDao.getCardContent(cardContentId);</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">        if (cardContent == null) {</span>
<span class="nc" id="L785">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }

<span class="fc" id="L788">        renameCategory(cardContent, oldName, newName);</span>
<span class="fc" id="L789">    }</span>

    // Note : the sub cards card type / card type reference are not changed. Should they ?

    /**
     * Rename the category in a card type / card type reference&lt;br&gt;
     * And do it also for the implementing cards as long as they are of the same project
     *
     * @param cardTypeOrRef the card type / card type reference (scope of the renaming)
     * @param projectId     the id of the project concerned (scope of the renaming)
     * @param oldName       the old name of the category
     * @param newName       the new name of the category
     */
    private void renameCategory(AbstractCardType cardTypeOrRef, Long projectId, String oldName,
        String newName) {
<span class="fc" id="L804">        cardTypeOrRef.getDirectAbstractResources().stream()</span>
<span class="fc" id="L805">            .forEach(resourceOrRef -&gt; renameCategoryIfMatch(resourceOrRef, oldName, newName));</span>

<span class="fc" id="L807">        cardTypeOrRef.getImplementingCards().stream()</span>
<span class="fc" id="L808">            .filter(card -&gt; Objects.equals(projectId, card.getProject().getId()))</span>
<span class="fc" id="L809">            .forEach(card -&gt; renameCategory(card, oldName, newName));</span>

<span class="fc" id="L811">        cardTypeOrRef.getDirectReferences().stream()</span>
<span class="pc" id="L812">            .forEach(cardRef -&gt; renameCategory(cardRef, projectId, oldName, newName));</span>
<span class="fc" id="L813">    }</span>

    /**
     * Rename the category in a card&lt;br&gt;
     * And do it also for each card's variants
     *
     * @param card    the card (scope of the renaming)
     * @param oldName the old name of the category
     * @param newName the new name of the category
     */
    private void renameCategory(Card card, String oldName, String newName) {
<span class="fc" id="L824">        card.getDirectAbstractResources().stream()</span>
<span class="fc" id="L825">            .forEach(resourceOrRef -&gt; renameCategoryIfMatch(resourceOrRef, oldName, newName));</span>

<span class="fc" id="L827">        card.getContentVariants().stream()</span>
<span class="fc" id="L828">            .forEach(cardContent -&gt; renameCategory(cardContent, oldName, newName));</span>
<span class="fc" id="L829">    }</span>

    /**
     * Rename the category in a card content&lt;br&gt;
     * And do it also for each sub cards
     *
     * @param cardContent the card content (scope of the renaming)
     * @param oldName     the old name of the category
     * @param newName     the new name of the category
     */
    private void renameCategory(CardContent cardContent, String oldName, String newName) {
<span class="fc" id="L840">        cardContent.getDirectAbstractResources().stream()</span>
<span class="fc" id="L841">            .forEach(resourceOrRef -&gt; renameCategoryIfMatch(resourceOrRef, oldName, newName));</span>

<span class="fc" id="L843">        cardContent.getSubCards().stream().forEach(card -&gt; renameCategory(card, oldName, newName));</span>
<span class="fc" id="L844">    }</span>

    // Note : a &quot;CardPropagator&quot; could be easily done with the methods here. See if useful

    /**
     * Replace the category of the resource if it matches the oldName
     *
     * @param resourceOrRef the resource or resource reference
     * @param oldName       the old name of the category
     * @param newName       the new name of the category
     */
    private void renameCategoryIfMatch(AbstractResource resourceOrRef, String oldName,
        String newName) {
<span class="fc bfc" id="L857" title="All 2 branches covered.">        if (Objects.equals(resourceOrRef.getCategory(), oldName)) {</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">            if (StringUtils.isBlank(newName)) {</span>
<span class="nc" id="L859">                resourceOrRef.setCategory(null);</span>
            } else {
<span class="fc" id="L861">                resourceOrRef.setCategory(StringUtils.trim(newName));</span>
            }
        }
<span class="fc" id="L864">    }</span>

    // *********************************************************************************************
    // Links stuff
    // *********************************************************************************************

    /**
     * Get all sticky note links of which the given resource / resource reference is the source
     *
     * @param resourceOrRefId the id of the resource / resource reference
     *
     * @return all sticky note links linked to the resource / resource reference
     */
    public List&lt;StickyNoteLink&gt; getStickyNoteLinkAsSrc(Long resourceOrRefId) {
<span class="fc" id="L878">        logger.debug(&quot;get sticky note links where the abstract resource #{} is the source&quot;,</span>
            resourceOrRefId);
<span class="fc" id="L880">        AbstractResource resource = resourceOrRefDao.findResourceOrRef(resourceOrRefId);</span>
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">        if (resource == null) {</span>
<span class="nc" id="L882">            throw HttpErrorMessage.relatedObjectNotFoundError();</span>
        }
<span class="fc" id="L884">        return resource.getStickyNoteLinksAsSrc();</span>
    }

    // *********************************************************************************************
    //
    // *********************************************************************************************

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>