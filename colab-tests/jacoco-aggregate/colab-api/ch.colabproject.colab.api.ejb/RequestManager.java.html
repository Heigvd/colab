<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RequestManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">colab-tests</a> &gt; <a href="../index.html" class="el_bundle">colab-api</a> &gt; <a href="index.source.html" class="el_package">ch.colabproject.colab.api.ejb</a> &gt; <span class="el_source">RequestManager.java</span></div><h1>RequestManager.java</h1><pre class="source lang-java linenums">/*
 * The coLAB project
 * Copyright (C) 2021 AlbaSim, MEI, HEIG-VD, HES-SO
 *
 * Licensed under the MIT License
 */
package ch.colabproject.colab.api.ejb;

import ch.colabproject.colab.api.model.tracking.Tracking;
import ch.colabproject.colab.api.model.user.Account;
import ch.colabproject.colab.api.model.user.User;
import ch.colabproject.colab.api.persistence.user.UserDao;
import ch.colabproject.colab.api.security.HttpSession;
import ch.colabproject.colab.api.security.permissions.Conditions.Condition;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Request sidekick.
 *
 * @author maxence
 */
@RequestScoped
<span class="fc" id="L31">public class RequestManager {</span>

    /** logger */
<span class="fc" id="L34">    private static final Logger logger = LoggerFactory.getLogger(RequestManager.class);</span>

    /**
     * Access to the persistence unit
     */
    @PersistenceContext(unitName = &quot;COLAB_PU&quot;)
    private EntityManager em;

    /**
     * User-related business logic
     */
    @Inject
    private UserDao userDao;

    /**
     * Websocket business logic
     */
    @Inject
    private WebsocketFacade websocketFacade;

    /**
     * HTTP session associated to current request
     */
    private HttpSession httpSession;

    /**
     * Timestamp as return by {@link System#currentTimeMillis() } the request starts at
     */
    private long startTime;

    /**
     * Base url request URL
     */
    private String baseUrl;

    /**
     * Id of the current user account
     */
    private Long currentAccountId;

    /**
     * To store condition which have already been evaluated
     */
<span class="fc" id="L77">    private final Map&lt;Condition, Boolean&gt; conditionCache = new HashMap&lt;&gt;();</span>

    /**
     * Indicates if current user can act as an admin. 0 = no sudo greater than 0 =&gt; sudo
     */
<span class="fc" id="L82">    private int sudoAsAdmin = 0;</span>

    /**
     * is the thread run in the so-called security transaction ?
     */
<span class="fc" id="L87">    private boolean inSecurityTx = false;</span>

    /**
     * Is the current transaction already completed ?
     */
<span class="fc" id="L92">    private boolean txDone = false;</span>

    /**
     * In some case, {@link Tracking tracking data} shouldn't be updated. Setting this boolean to
     * prevent allow such behaviour.
     */
<span class="fc" id="L98">    private boolean doNotTrackChange = false;</span>

    /**
     * Get request base url
     *
     * @return url
     */
    public String getBaseUrl() {
<span class="fc" id="L106">        return baseUrl;</span>
    }

    /**
     * Set the request base url
     *
     * @param baseUrl request base url
     */
    public void setBaseUrl(String baseUrl) {
<span class="fc" id="L115">        this.baseUrl = baseUrl;</span>
<span class="fc" id="L116">    }</span>

    /**
     *
     * @return the current http session
     */
    public HttpSession getHttpSession() {
<span class="fc" id="L123">        return this.httpSession;</span>
    }

    /**
     * Attach httpSession to this request
     *
     * @param httpSession http session
     */
    public void setHttpSession(HttpSession httpSession) {
<span class="fc" id="L132">        this.httpSession = httpSession;</span>
<span class="fc" id="L133">    }</span>

    /**
     * Get the current authenticated account
     *
     * @return the current account or null if none
     */
    public Account getCurrentAccount() {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (this.httpSession != null) {</span>
<span class="fc" id="L142">            return userDao.findAccount(this.httpSession.getAccountId());</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        } else if (this.currentAccountId != null) {</span>
<span class="fc" id="L144">            return userDao.findAccount(this.currentAccountId);</span>
        }
<span class="fc" id="L146">        return null;</span>
    }

    /**
     * Get the current authenticated user
     *
     * @return the current user or null if none
     */
    public User getCurrentUser() {
<span class="fc" id="L155">        Account account = this.getCurrentAccount();</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (account != null) {</span>
<span class="fc" id="L158">            return account.getUser();</span>
        } else {
<span class="fc" id="L160">            return null;</span>
        }
    }

    /**
     * set time the current request started
     *
     * @param timestamp start timestamp
     *
     */
    public void setStartTime(long timestamp) {
<span class="fc" id="L171">        this.startTime = timestamp;</span>
<span class="fc" id="L172">    }</span>

    /**
     * Return the time the request started
     *
     * @return start time timestamp in ms
     */
    public long getStartTime() {
<span class="fc" id="L180">        return startTime;</span>
    }

    /**
     * Is the request ran by an authenticated user ?
     *
     * @return true if the current user is fully authenticated
     */
    public Boolean isAuthenticated() {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        return this.getCurrentAccount() != null;</span>
    }

    /**
     * Set the current account.
     *
     * @param account new current account
     */
    public void login(Account account) {
<span class="fc" id="L198">        HttpSession session = this.getHttpSession();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (session != null) {</span>
<span class="fc" id="L200">            session.setAccountId(account.getId());</span>
        }
<span class="fc" id="L202">        this.currentAccountId = account.getId();</span>
<span class="fc" id="L203">    }</span>

    /**
     * Clear current account and unsubscribe from all websocket channels.
     */
    public void logout() {
<span class="fc" id="L209">        HttpSession session = this.getHttpSession();</span>
<span class="fc" id="L210">        this.currentAccountId = null;</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (session != null) {</span>
<span class="fc" id="L212">            session.setAccountId(null);</span>
<span class="fc" id="L213">            conditionCache.clear();</span>
<span class="fc" id="L214">            websocketFacade.signoutAndUnsubscribeFromAll(this.getHttpSession().getSessionId());</span>
        }
<span class="fc" id="L216">    }</span>

    /**
     * Is current transaction still alive ?
     *
     * @return true if current tx is not dead
     */
    private boolean txExists() {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        return !this.txDone;</span>
    }

    /**
     * Execute some piece of code with admin privileges.
     *
     * @param action code to execute with admin privileges
     */
    public void sudo(Runnable action) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (txExists()) {</span>
            // make sure to flush to check every pending changes before granting admin rights
<span class="fc" id="L235">            em.flush();</span>
        }

<span class="fc" id="L238">        this.sudoAsAdmin++;</span>
<span class="fc" id="L239">        logger.trace(&quot;Sudo #{}&quot;, this.sudoAsAdmin);</span>
<span class="fc" id="L240">        action.run();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (txExists()) {</span>
            // make sure to flush to apply all pending changes with admin rights
<span class="fc" id="L243">            em.flush();</span>
        }

<span class="fc" id="L246">        logger.trace(&quot;EndOfSudo #{}&quot;, this.sudoAsAdmin);</span>

<span class="fc" id="L248">        this.sudoAsAdmin--;</span>
<span class="fc" id="L249">    }</span>

    /**
     * Execute some piece of code with admin privileges and return something.
     *
     * @param &lt;R&gt;    return type
     * @param action code to execute with admin privileges
     *
     * @return action result
     *
     * @throws java.lang.Exception if something is thrown during the call
     */
    public &lt;R&gt; R sudo(Callable&lt;R&gt; action) throws Exception {
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (txExists()) {</span>
            // make sure to flush to check every pending changes before granting admin rights
<span class="fc" id="L264">            em.flush();</span>
        }
<span class="fc" id="L266">        this.sudoAsAdmin++;</span>
<span class="fc" id="L267">        logger.trace(&quot;Sudo #{}&quot;, this.sudoAsAdmin);</span>
<span class="fc" id="L268">        R result = action.call();</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (txExists()) {</span>
            // make sure to flush to apply all pending changes with admin rights
<span class="fc" id="L271">            em.flush();</span>
        }
<span class="fc" id="L273">        logger.trace(&quot;EndOfSudo #{}&quot;, this.sudoAsAdmin);</span>
<span class="fc" id="L274">        this.sudoAsAdmin--;</span>

<span class="fc" id="L276">        return result;</span>
    }

    /**
     * Is the currentUser is an admin or sudo as an admin ?
     *
     * @return true if current user can act as an admin
     */
    public boolean isAdmin() {
        // the sudoAsAdmin is done at first,
        // so we do not need to get the current user if this condition is fulfilled
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (sudoAsAdmin &gt; 0) {</span>
<span class="fc" id="L288">            return true;</span>
        }

<span class="fc" id="L291">        User currentUser = this.getCurrentUser();</span>
<span class="fc bfc" id="L292" title="All 4 branches covered.">        return currentUser != null &amp;&amp; currentUser.isAdmin();</span>
    }

    /**
     * Register condition result
     *
     * @param condition the condition
     * @param result    the result
     */
    public void registerConditionResult(Condition condition, Boolean result) {
<span class="fc" id="L302">        this.conditionCache.put(condition, result);</span>
<span class="fc" id="L303">    }</span>

    /**
     * Get the cached condition result
     *
     * @param condition condition
     *
     * @return true or false if the condition is cached, null if the condition has not been
     *         evaluated yet
     */
    public Boolean getConditionResult(Condition condition) {
<span class="fc" id="L314">        return this.conditionCache.get(condition);</span>
    }

    /**
     * Is the thread run in a transaction dedicated to security condition evaluation
     *
     * @return true/false
     */
    public boolean isInSecurityTx() {
<span class="fc" id="L323">        return inSecurityTx;</span>
    }

    /**
     * Change the inSecurityTx flag
     *
     * @param inSecurityTx new flag
     */
    public void setInSecurityTx(boolean inSecurityTx) {
<span class="fc" id="L332">        this.inSecurityTx = inSecurityTx;</span>
<span class="fc" id="L333">    }</span>

    /**
     * Check if the current transaction is already done
     *
     * @return whether or not the current transaction is already done
     */
    public boolean isTxDone() {
<span class="nc" id="L341">        return txDone;</span>
    }

    /**
     * Mark the current transaction as done or undone
     *
     * @param txDone whether or not the current transaction is already done
     */
    public void setTxDone(boolean txDone) {
<span class="fc" id="L350">        this.txDone = txDone;</span>
<span class="fc" id="L351">    }</span>

    /**
     * Set Do-Not-Track-Change boolean
     *
     * @param value the new value
     */
    public void setDoNotTrackChange(boolean value) {
<span class="fc" id="L359">        this.doNotTrackChange = value;</span>
<span class="fc" id="L360">    }</span>

    /**
     * Get Do-Not-Track-Change value
     *
     * @return should ou shouldn't track entity updates?
     */
    public boolean isDoNotTrackChange() {
<span class="fc" id="L368">        return doNotTrackChange;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>